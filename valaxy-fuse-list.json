[{"title":"51单片机编程","tags":["笔记","51单片机","C"],"categories":["笔记"],"author":"akorin","excerpt":"\n51单片机主要使用的函数\n \n","link":"/posts/51microcopmuter","content":"\n51单片机主要使用的函数\n \n<!-- more -->\n\n## 定时器&中断\n- 定时器\n  - Timer0\n  - Timer1\n- 定时模式\n  - 模式0：13位定时/计数器\n  - 模式1：16位定时/计数器\n  - 模式2：8位自动重载/定时计数器\n  - 模式3：仅限定时器0，Timer0分为两个8位计数器\n- 中断\n  - 外部中断0，使用中断号0\n  - 定时中断0，使用中断号1\n  - 外部中断1，使用中断号2\n  - 定时中断1，使用中断号3\n  - 串口中断\n\n> **计算定时时间公式**\n\n$$\n(2^{16}-X)\\times \\frac{12}{f_n}=Time\n$$\n\n> 其中X为定时器初始计数值（填装进Tlx，Thx寄存器）， $f_n$ 为晶振频率\n\n\n:::code-group\n<<< @/code/C/51/51withTimer.c{c}[51单片机定时器及外部中断设计]\n:::\n\n## 写内部FLASH\n\nSTC89C52/AT89C52内部FLASH扇区地址：\n\n| 第一扇区    | 第二扇区    | 第三扇区    | 第四扇区    |\n| ----------- | ----------- | ----------- | ----------- |\n| 2000h~21FFh | 2200h~23FFh | 2400h~25FFh | 2600h~27FFh |\n\n| 第五扇区    | 第六扇区    | 第七扇区    | 第八扇区    |\n| ----------- | ----------- | ----------- | ----------- |\n| 2800h~29FFh | 2A00h~2BFFh | 2C00h~2DFFh | 2E00h~2FFFh |\n\n- 操作模式\n  - 0x00: 空闲\n  - 0x01: 读出\n  - 0x02: 写入\n  - 0x03: 擦除\n- 操作流程：\n\n\n<center>\n\n```mermaid\n\nstateDiagram\n\n  设定ISP等待时间 --> 设定ISP模式 \n  设定ISP模式 --> 设定ISP操作地址 \n  设定ISP操作地址 --> 关闭全局定时器 \n  关闭全局定时器 --> ISP_TRIG寄存器存入0x46 \n  ISP_TRIG寄存器存入0x46 --> ISP_TRIG寄存器存入0xB9 \n  ISP_TRIG寄存器存入0xB9 --> 等待一个空闲周期 \n  等待一个空闲周期 --> 退出ISP模式\n\n```\n</center>\n\n  - 关闭全局定时器是为了确保连续往ISP_TRIG寄存器存入0x46和0xB9，才能使命令生效\n  - 推出ISP模式就是把寄存器ISP_CONTR、ISP_CMD、ISP_TRIG清空\n\n:::code-group\n<<< @/code/C/51/InterFLASH.c{c}[内部FLASH读取设计]\n:::\n\n\n## 驱动数码管\n\n数码管有共阴和共阳的类型，引脚分布从左到右一般对应的是从最上面的灯开始，顺时针数再到中间的灯，最后的是右下角的点。转换成程序来中对应的位为hgfedcba，从高到低排列\n\n数码管结构及引脚如下：\n```\n###     a\n# #  f     b\n###     g\n# #  e     c\n### .   d     h\n```\n\n因此以共阳极的数码管为例，驱动数字为1时，应往引脚传输的电平为:11111001，对应十六进制为0xF9\n\n:::code-group\n<<< @/code/C/51/LEDMatrix.c{c}[数码管驱动]\n:::\n","cover":"https://pic.akorin.icu/20250315185018179.png","date":"2025-03-15"},{"title":"Japan计划！","tags":["计划","日本"],"categories":["旅行计划"],"author":"akorin","excerpt":"\n去霓虹准备的东西以及大致路线、要去圣地巡礼的地点。具体路线根据住宿的位置来决定\n\n","link":"/posts/JapanTravel","content":"\n去霓虹准备的东西以及大致路线、要去圣地巡礼的地点。具体路线根据住宿的位置来决定\n\n<!-- more -->\n\n# 霓虹Plan\n\n## 行前准备\n### 必备证件\n- 护照（直接拿身份证去办）\n- 签证（淘宝代办）\n- 身份证复印件\n\n::: danger\n\n不要带**无磁条**（单芯片）的银联卡（特指新版本的工行卡），ATM机读取不了无磁条的银行卡，但是部分商家POS机（麦当劳等）能够读取单芯片银联卡\n\n:::\n\n### 交通卡与通讯\n- SUICA/PASMO卡（覆盖关东关西）\n- 日本流量卡\n\n### 必备软件\n- agoda/安彼迎（酒店、民宿）\n- Google地图\n\n### 巡礼地图\n- [anitabi](https://anitabi.cn/)\n\n## 机票方案\n### （贵阳→大阪→贵阳）\n|      | 路线           | 时间                    | 价格    | 备注                 |\n| ---- | -------------- | ----------------------- | ------- | -------------------- |\n| 去程 | 贵阳→济南→大阪 | 11:15~20:45+转机        | ￥1940  | 去程和返程机票一起订 |\n| 返程 | 大阪→济南→贵阳 | 21:45~19:05+转机(+1day) | ------- | 在济南多呆一天       |\n\n## 行程路线📅（15天）\n按「城市、作品、地点」分段，标注交通时间与核心体验：\n\n### 关西篇\n#### 大阪\n##### 路线：\n![大阪](https://www.helloimg.com/i/2025/01/30/679b70e66e19d.png)\n- **大致路线**：关西国际机场→大阪城公园→通天阁→道遁窟→心斋桥（紫色路线）\n- **大学**：大阪大学\n\n#### 奈良\n- **大致路线**：奈良公园→春日大社→若草山（可选）\n![屏幕截图 2025-01-30 220625.png](https://www.helloimg.com/i/2025/01/30/679b863c57495.png)\n\n#### 宇治\n##### 圣地巡礼：\n**《京吹》**\n- **《京吹》**：宇治站、宇治桥、大吉山（可选）、宇治站台、京坂黄檗\n##### 路线：\n![宇治](https://www.helloimg.com/i/2025/01/30/679b7649abfc1.png)\n- **大致路线**：宇治站→宇治桥→大吉山（可选）→宇治站台→京坂黄檗→京都府立菟道高等学校\n\n#### 京都\n##### 圣地巡礼：\n**《轻音少女》《玉子市场》**\n- **《玉子市场》**：宇治站、宇治桥、大吉山（可选）、宇治站台、京坂黄檗\n- **《轻音少女》**：豐鄉町立豐鄉小學校\n##### 路线：\n- **大致路线**：黃檗（京阪）→株式会社京都→千本鸟居→伏见稻荷大社→鴨川三角洲→出町桝形商店街\n![屏幕截图 2025-01-30 212247.png](https://www.helloimg.com/i/2025/01/30/679b7bfeb6a9d.png)\n京都市→豐鄉→豐鄉町立豐鄉小學校\n![屏幕截图 2025-01-30 212848.png](https://www.helloimg.com/i/2025/01/30/679b7d5fa7fe9.png)\n### 中部篇\n#### 名古屋\n- **可去地点**：名古屋城\n\n#### 滨松\n##### 圣地巡礼：\n- **《星之梦》**：WINS笠井屋ビル附近\n![屏幕截图 2025-01-30 215548.png](https://www.helloimg.com/i/2025/01/30/679b83a76bb50.png)\n\n#### 静冈\n##### 圣地巡礼：\n- **《摇曳露营》**：富士山本宮淺間大社\n- **可去地点**：三保之松原、富士山本宮淺間大社\n##### 路线：\n![屏幕截图 2025-01-30 215340.png](https://www.helloimg.com/i/2025/01/30/679b833c0afe5.png)\n- **大致路线**：静冈→富士\n- **大学**：静冈大学\n\n### 关东篇\n#### 东京\n##### 圣地巡礼：\n**《少女歌剧》《mygo》《mujica》《GBC》《孤独摇滚》《P5》《我心危》《路人女主》《命运石之门》**\n- **《少女歌剧》**： 品川水族馆、和光本馆、东京塔、芝公园、女神桥\n- **《mygo》**：日本女子大学（羽丘）、サンシャイン60通り交差点、千登世步道桥、千登世小桥、飞鸟山公园\n- **《mujica》**：台场海滨公园\n- **《GBC》**：島村楽器 ラゾーナ川崎店、川崎アゼリア、川崎駅前\n- **《孤独摇滚》**：下北沢\n![guduyaogun.png](https://www.helloimg.com/i/2025/01/30/679b549cefea6.png)\n- **《P5》**：東京都世田谷区三軒茶屋２丁目１４−20\n- **《我心危》**：全家便利店原町二丁目店\n- **《路人女主》**：のぞき坂\n- **《命运石之门》**：秋叶原广播会馆、カフェ メイリッシュ（女仆咖啡厅）\n\n##### 路线：\n![大致路线图](https://www.helloimg.com/i/2025/01/30/679b6348e6b97.png)\n- **大致路线**：横滨→川崎→东京\n- **可去地点**：涩谷Sky、浅草寺、日枝神社（你的名字取景地）\n- **大学**：东京大学、东京工业大学、早稻田大学\n\n#### 镰仓\n##### 路线：\n- **可去地点**：七里ガ浜","cover":"https://pic.akorin.icu/conwtz3p.png","date":"2025-01-29"},{"title":"C++学习记录","tags":["学习","编程","C++"],"categories":["笔记"],"author":"akorin","excerpt":"\n## 怎么这么难啊\n在C语言的基础上继续学习CPP\n\n","link":"/posts/gccSimpleLearn","content":"\n## 怎么这么难啊\n在C语言的基础上继续学习CPP\n\n<!-- more -->\n\n## C++基础知识\n\n### `extern` 的用法\n\n在预编译的过程中，会自动展开头文件。因此定义在头文件的变量就会被多次定义。  \n`extern` 关键字用于声明一个变量或函数，使其可以在其他文件中访问，而不在当前文件中分配内存。  \n\n::: info 总结\n头文件只做变量的声明，不能做变量的定义  \n头文件声明变量可以采用extern的方式\n:::\n\n### 变量作用域\n与C不同C++多了几种作用域。作用域决定了变量的生命周期和可见性。\n\n1. 全局作用域：在函数外部声明变量，一般只在需要的时候才使用，便于代码维护\n2. 局部作用域：在函数内部、 `if` 语句或 `for` 循环内声明的变量。它们只在声明的代码块内被访问。\n3. 命名空间作用域：在命名空间中声明的变量\n4. 类作用域：在类内部声明的变量和成员函数。成员变量和成员函数只能通过类的对象访问，而在某些情况（如静态成员）可以直接通过类名访问。\n5. 块作用域：是局部作用域的一个特例，在函数中额外用大括号 `{}` 来包围的代码块内声明的变量，这些变量只能在代码块内被访问，即使在函数内但是超出代码块也依旧不能访问。\n\n\n:::code-group\n```C++ [命名空间作用域]\nnamespace MyNamespace {\n  int namespaceVar = 10;\n}\n\nint main(){\n  int a = MyNamespace::namespaceVar;\n}\n```\n```C++ [类作用域]\nclass MyClass {\n  public:\n    int classVar;\n}\n\nint main(){\n  MyClass obj;\n  obj.classVar = 10;\n}\n```\n```C++ [块作用域]\nvoid fun() {\n  {\n    int a = 1;\n  }\n  // 下列代码尝试块外访问块内变量会导致编译错误\n  // int b = a;\n}\n```\n:::\n\n### 存储空间\nC++通过存储的数据类型、生命周期和作用域来划分。\n\n1. 代码区（Code Segment/Text Segment）：存储程序执行代码（机器指令）的内存区域，只读，在执行程序时不会改变。\n2. 全局/静态存储区（Global/Static Storage Area）：存储全局变量和静态变量的区域。\n3. 栈区（Stack Segment）：存储局部变量、函数参数、返回地址等的内存区域。栈是后进先出的数据结构，存储函数调用和自动变量。\n4. 堆区（Heap Segment）：由程序员通过动态分配函数（ `new` 或 `malloc` ）分配的内存区域。堆的内存分配和释放是手动的，由程序员需要负责管理的内存，避免内存泄漏或野指针等问题。\n5. 常量区（Constant Area）：存储如字符串常量、 `const` 饰的全局变量的区域，这部分内存也是只读的。在C++中，使用双引号括起来的字符串字面量通常存储在常量区。若 `const` 修饰的全局变量的值在编译时就已确定，则也可能存储在常量区。\n\n:::tip \n`const` 修饰的变量是只读的，编译器处理时一般时直接将 `const` 修饰的变量替换成其初始化的值。默认情况下 `const` 对象被设定为仅在文件内有效，因此当多个文件中出现了同名的 `const` 修饰的变量时，其实相当于在不同的文件中定义了不同的变量。比如filea.c和fileb.c都包含了fileh.h文件，而fileh.h中声明了一个 `const` 修饰的变量var，filea.c和fileb.c中引用该变量其实是不同的，即filea.c中的var与fileb.c中的var地址不相同。\n:::\n\n[代码源](https://gitbookcpp.llfc.club/sections/cpp/base/cppbase02.html)\n:::code-group\n```C++ [示例代码]\n#include <iostream>\n#include <cstring> // 用于strlen\n\n// 全局变量，存储在全局/静态存储区\nint globalVar = 10;\n\n// 静态变量，也存储在全局/静态存储区，但仅在其声明的文件或函数内部可见\nstatic int staticVar = 20;\n\nvoid func() {\n    // 局部变量，存储在栈区\n    int localVar = 30;\n\n    // 静态局部变量，虽然声明在函数内部，但存储在全局/静态存储区，且只在第一次调用时初始化\n    static int staticLocalVar = 40;\n\n    std::cout << \"Inside func:\" << std::endl;\n    std::cout << \"localVar = \" << localVar << std::endl;\n    std::cout << \"staticLocalVar = \" << staticLocalVar << std::endl;\n\n    // 尝试通过动态内存分配在堆区分配内存\n    int* heapVar = new int(50);\n\n    std::cout << \"heapVar = \" << *heapVar << std::endl;\n\n    // 释放堆区内存（重要：实际使用中不要忘记释放不再使用的堆内存）\n    delete heapVar;\n}\n\nint main() {\n    // 访问全局变量\n    std::cout << \"Inside main:\" << std::endl;\n    std::cout << \"globalVar = \" << globalVar << std::endl;\n    std::cout << \"staticVar = \" << staticVar << std::endl; // 注意：staticVar在外部不可见（除非在同一个文件中或通过特殊方式）\n\n    // 调用函数，展示栈区和堆区的使用\n    func();\n\n    // 字符串常量通常存储在常量区，但直接访问其内存地址并不是标准C++的做法\n    // 这里我们仅通过指针来展示其存在\n    const char* strConst = \"Hello, World!\";\n    // 注意：不要尝试修改strConst指向的内容，因为它是只读的\n    std::cout << \"strConst = \" << strConst << std::endl;\n    // 尝试获取字符串常量的长度（这不会修改常量区的内容）\n    std::cout << \"Length of strConst = \" << strlen(strConst) << std::endl;\n\n    return 0;\n}\n```\n```[输出结果]\nInside main:\nglobalVar = 10\nstaticVar = 20\nInside func:\nlocalVar = 30\nstaticLocalVar = 40\nheapVar = 50\n```\n:::\n从下图中可以看出字符串都存储在了常量区。\n![alt text](https://pic.akorin.icu/20250712171019110.png)\n\n\n### 引用\n\n引用可以看作是另一个变量的别名，其用法也较为简单：\n```C++\nint a = 1;\nint &b = a;\n```\n使用符号 `&` 表示引用，此时变量 `a` 和 `b` 的地址相同。此时修改b的值相当于修改a的值，b就是a的别名。\n\n:::warning 注意\n1. 必须初始化。在创建引用时，必须指向一个已存在的对象。\n2. 一旦引用绑定后就不能再修改。\n3. 不能存在空引用。\n:::\n\n#### 左值引用和右值引用\n在C++中左值( `lvalue` )和右值( `rvalue` )是表达式的两种基本分类，它们决定了表达式的结果在内存中的位置和状态。  \n**左值**通常指具有持久状态的对象，有明确的内存地址，可以被多次赋值。左值引用是C++98就有的特性。  \n**右值**是临时、没有持久状态的值（临时对象或即将被销毁的对象），通常没有内存地址，或其内存地址在表达式结束后变得无效。右值引用是C++11新增的特性。\n\n:::code-group\n```C++[左值引用]\nint a = 10;\nint& b = a; // b是a的左值引用\n```\n```C++[右值引用]\nint&& c = 20; // c是整数字面量20的右值引用（但这种情况不常见，通常用于函数参数或返回值）\n\nstd::string foo() {\n    return std::string(\"Hello, World!\"); // 返回的临时字符串是一个右值\n}\n\nstd::string &&d = foo(); // d是foo()返回的临时字符串的右值引用\n```\n:::\n右值引用的主要用途是作为函数参数（实现移动语义）和返回值（允许链式调用等）。\n\n### 指针\n\n指针是一种特殊变量。它存储的是另一个变量的地址，而不是该变量本身。通过操作指针可以直接操作内存的数据。  \n`nullptr` 为空指针，在C++中 0为 `false` ，非0为 `true`。  \n指针存储的是地址，因此指针有两种赋值方式：\n1. **直接赋值**，但是这不常用。\n2. 利用**取地址符号** `&` 获取变量的地址并将其传给指针。取地址符号 `&` 获取的地址只能传给指针类型的变量，否则会报错。\n\n```C++\nint var = 10;\nint *ptr = &var;\n```\n指针本身也是个变量，其存储的是另一个变量的地址，因此计算机也会为指针开辟空间，指针有自己的地址。  \n再看下面的代码：\n```C++\nint var = 10;\nint *ptr1 = &var;\nint *ptr2 = ptr1;\n```\nptr1是指针，存储的是var的地址，ptr2也是指针，获取了ptr1存储的值也就是var的地址，此时ptr2也指向了var。\n\n#### 指针和引用的区别\n\n指针与引用类似，都能够对其它对象进行间接地访问，但是指针又与引用有许多不同。\n1. 指针本身就是一个对象，允许对指针赋值和拷贝，在指针地生命周期内可以指向不同的对象，而引用在初始化时就已固定。\n2. 指针无须初始化。在指针未初始化时其存储的值是不确定的。\n\n#### 万能指针和指向指针的指针\n\n`void*` 是一种特殊的指针类型，能够存放任意对象的地址。`void*` 指针存放一个地址，但是该地址存放的数据类型是不知道的。  \n由于不知道 `void*` 指向的对象的类型，因此不能利用 `void*` 直接去操作指向的对象。\n\n`void*` 主要用来和别的指针进行比较、作为函数的输入或输出，或赋给另一个 `void*` 指针。\n\n除了万能指针还有指向指针的指针，即`**ptr`，指向指针的指针存取的是另一个指针的地址。\n\n#### 指针和数组\n\n指针能够通过自增和自减来控制指针存取的地址，通过这种特性，将指针指向一个数组，并让指针自增自减就能起到指针选取不同数组内的元素。  \n当指针指向数组时，一般指向数组的第一个元素。  \n\n```C++\n//指针可以进行算术运算，如递增（++）和递减（--），\n// 这些操作会改变指针所指向的内存地址。但是，这种操作仅限于指向数组元素的指针。\nint arr[5] = {1, 2, 3, 4, 5};\nint *ptr_arr = arr;\nstd::cout << \"ptr_arr is : \" << ptr_arr << std::endl;\nint firstElement = *ptr_arr;\nstd::cout << \"firstElement is \" << firstElement << std::endl;\n// 递增指针\n++ptr_arr; // ptr 现在指向 arr[1]\nstd::cout << \"ptr_arr is : \" << ptr_arr << std::endl;\n// 访问新位置的值\nint secondElement = *ptr_arr; // secondElement 等于 2\nstd::cout << \"secondElement is \" << secondElement;\n```\n上面的代码可以看出指针指向数组时，**数组不用取地址符号**。因为数组名在表达式中会自动转换为**指向其首元素的指针**，即 `arr` 是一个指针并指向数组的第一个元素，也即 `arr` 存取数组第一个元素的地址。在上面的代码中 `arr` 表示数组的首地址，类型为 `int*` 等价于\n```C++\narr = &arr[0];\nint *ptr_arr = &arr[0];\n```\n\n还有指向整个数组的指针：\n```C++\nint a[5] = {1, 2, 3, 4, 5};\nint (*para)[5] = &a;\n```\n这里的 `para` 不是指针数组，而是**数组指针**，这意味着 `para` 应看作成一个整体，其数据类型为 `int*[5]`。  \n因此 `para[1]` 并不是指代数组 `a` 的第二个元素，而是偏移了一个 `int[5]` 的单位后的野指针。 `para` 本身不是数组，而是指向了一整个数组的**指针**。\n```C++\nstd::cout << (*para)[1] << std::endl;\n```\n`(*para)[1]` 才是指代数组 `a` 的第二个元素，其中 `para` 在物理意义上存取数组 `a` 的首地址，但在C++中是存取整个数组的地址。  \n\n`a` 等价于 `para[0]` ， `a[0]` 等价于 `(*para)[0]`或 `*para` ， `(*para)[1]` 等价于 `para[0][1]` 或 `a[1]`。  \n\n在使用**数组指针**时，`*para[0]` 这种写法不够清晰，且容易引起歧义，因此不能这么写，应写成 `(*para)[0]`。\n\n容易混淆的是`para[0][1]` 前一个 `[]` 表示指针位置（指向的地址），后一个 `[]` 表示数组指针指代数组的元素。\n\n这个在普通的指针上也有类似的情况：\n```C++\nint a = 1;\nint *p = &a;\n```\n `p` 等价于 `p[0]`，而 `p[1]` 就是野指针了。\n\n与指针数组对比：\n```C++\nint *para[5];\n```\n上面的代码意味着 `para` 数组有5个 `int` 型指针。  \n指针数组有n个指针，而数组指针只有一个。\n\n### `const` 关键字\n\n`const` 修饰的变量为常量，必须初始化且在不能修改。通过 `const` 提高代码的安全性和可读性。\n\n指针本身也是变量，因此也能够被`const`修饰。\n\n#### `const` 在声明变量中的位置\n\n`const` 关键字一般放在变量类型之前：\n```C++\nconst int a =10;\n```\n也可以放在变量类型之后，但比较少见：\n```C++\nint const a = 10;\n```\n\n#### `const`引用\n\n当有 `const` 关键词修饰变量时，其引用也必须是 `const` 修饰的；被引用地变量没有 `const` 修饰时，其引用也可以用 `const` 修饰。  \n`const` 修饰的引用变量类型可以与被引用的变量类型不同，在编译过程中会进行隐式地类型转换。  \nC++ 允许常量引用绑定到类型不同的右值或临时变量。\n\n```C++\ndouble dval = 3.14;\nint &rd = dval;       // [!code error] 错误\nconst int &rt = dval; // 正确\n// 相当于\nconst int temp = dval;\nconst int &rt = temp;\n```\n此时 `rt` 绑定了一个临时对象 `temp`， 对象 `temp` 进行类型转换。临时对象常常被称作**临时量**。\n\n#### 常量指针\n\n指针也能够被 `const` 修饰，类似于常量对象，在初始化后指向的对象就不能被改变。  \n要指向常量对象，必须使用常量指针：\n```C++\nconst double PI = 3.14;\ndouble * ptr = &PI;       // [!code error] 错误\nconst double *cptr0 = &PI; // 正确  普通指针\nconst double *const cptr1 = &PI; // 正确  常量指针\n```\n`cptr0` 是指向常量的指针，可以修改指向的对象。  \n`cptr1` 是指向常量的**常量指针**，不能修改指向的对象。\n\n```C++\nconst int a = 10;\nconst int b = 20;\nint c = 30;\nconst int *ptra = &a;\nptra = &b;  // 正确\nconst int *const ptrb = &a;\nptrb = &b;  // [!code error] 错误\nconst int *ptrc = &c;  // 正确\nconst double *ptrc = &c;  // [!code error] 错误\n```\n在上面代码中 \n```C++\nconst int *const ptrb = &a;\n```\n前一个 `const` 称作底层 `const` ，后一个 `const` 称作顶层 `const`。\n\n1. **顶层** `const` 表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。\n2. **底层** `const` 则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层 `const` 也可以是底层 `const` ，这一点和其他类型相比区别明显。\n\n```C++\nconst int *ptrc = &c;\nconst double *ptrc = &c;// [!code error]\n```\nC++ **不允许**不同类型的指针直接相互赋值，即使都是常量指针，这点与常量引用不同。  \n只有底层 `const` 修饰指针，表示该指针不能修改指向对象的值，但是可以修改指向的对象。\n\n#### `constexpr` 和常量表达式\n\n`constexpr` 是 **C++11**新标准引入的新类型。C++11允许将变量声明为 `constexpr` 类型，让编译器在编译期间就将该类型的值转换成字面量。 `constexpr` 修饰的变量也一定是常量。\n\n`constexpr` 修饰的指针其初始值必须是0或 `nullprt` ，也可以是某个固定地址中的对象（全局对象等）。  \n\n### `auto` 关键词\n\n有时候需要从表达式的返回值赋值给变量，这使得创建的变量要与表达式相同，在工程中要实现这一目标比较不变甚至无法实现，C++11 新标准引入 `auto` 类型说明符来自动推算变量类型。  \n但是一条 `auto` 只能声明一种基本数据类型。\n```C++\nauto a = 0, pi = 3.14;// [!code error]\n```\n可以在 `auto` 前加上 `const` 来指示推断数据类型为常量。\n\n### `decltype` 关键词\n\n`decltype(function()) x` 通过自动推断函数 `function()` 的返回值类型，并用它来声明变量 `x` ，使 `x` 与 `function()` 的返回值类型一致。\n\n### `for` 循环\nc++中 `for` 循环多了“范围循环”的形式：\n```C++\nfor (a : b){}\n```\n在**C++11**的 `for` 范围循环代码块中，若出现了向量 `vector` ，在背后会自动调用向量的 `begin()/end()` 函数，即可以直接写成：\n```C++\nstd::vector<int> vec = {1 , 2 ,3};\nfor(auto c : vec){}\n```\n等价于：\n```C++\nstd::vector<int> vec = {1 , 2 ,3};\nfor (auto it = vec.begin(); it != vec.end(); ++it) {}\n```\n\n### 向量 `vector`\n\n向量 `vector` 是C++标准模板库(STL)中的一种序列容器，能够动态管理可变大小的数组。\n\n定义一个向量：\n```C++\nstd:vector<int> numbers;  //整数向量\nstd:vector<std:string> words; //字符串向量\n```\n\n向量可以直接增删改查：\n- `push_back()` ：在向量末尾添加一个元素。\n- `pop_back()` ：移除向量末尾的元素。\n- `insert()` ：在指定位置插入元素。\n- `erase()` ：移除指定位置的元素或范围内的元素。\n- `clear()` ：移除所有元素。\n- `operator[]` ：通过索引访问元素。\n- `at()` ：通过索引访问元素，带边界检查。\n- `front()` ：返回指向第一个元素（底层元素）的迭代器。\n- `back()` ：返回指向最后一个元素迭代器。\n- `size()` ：返回向量中元素的数量。\n- `capacity()`：返回向量目前为止分配的存储容量。\n- `empty()` ：检查向量是否为空。\n- `begin()` : 返回指向向量第一个元素的迭代器，\n- `end()` : 指向“最后一个元素之后”的位置（不能解引用）。\n- `data()` ： 返回指向第一个元素的指针。\n- `find()` ： 在向量中查找所需的元素。\n- `reverse()` ： 预留内存。\n\n:::info\n虽然向量可以直接像数组一样操作和赋值，但是向量本身并不是直接指向第一个元素的指针，而是一个对象，因此需要使用 `vector.begin()` 或 `vector.data()` 来获取向量第一个元素的迭代器或指针。\n```C++\nfor (auto i = vector; i != vector.end(); i++){} // [!code error]\nfor (auto i = vector.begin(); i != vector.end(); i++){}\n```\n:::\n\n#### 二维向量：\n```C++\nstd::vector<std::vector<int>> matrix(3, std::vector<int>(4, 0));\n```\n\n#### 向量内存优化\n\n向量会动态地管理内存，自动调整向量的容量以适应新增或删除的元素，频繁地内存分配可能会影响性能。  \n1. 使用 `reverse()` 来预留内存，减少内存分配地次数。\n2. 使用 `shrink_to_fit()` 释放向量的多余容量，匹配向量大小。\n\n### 迭代器\n\n迭代器( `Interator` ) 是C++标准模板库( `STL` ) 的一个重要概念。迭代器就像一个指针，但是迭代器只能访问容器内的元素，因此比指针更加安全。  \n\n一些具有迭代器的容器（向量等）都会有成员函数 `begin()` 和 `end()` 来返回迭代器。\n\n#### 迭代器的运算\n\n- `*iter` ：返回迭代器所指元素的引用。\n- `iter->mem` ： 解引用迭代器所指的元素，等价于 `(*iter).mem`\n- `++iter` ： 指向下一个元素\n- `--iter` ： 指向上一个元素\n- `iter1 == iter2` ： 判断两个迭代器是否相等\n- `iter1 != iter2` ： 判断两个迭代器是否不相等\n\n比较类似于指针指向数组。\n\n#### 迭代器失效\n\n由于向量 `vector` 可以动态增长，但是不能再 `for` 循环中向 `vector` 对象添加元素。且任何能够可能改变 `vector` 对象容量的操作（ `push_back` 、 `pop_back` 等）都会使该 `vector` 对象的迭代器失效。\n```C++\n//注意下面逻辑错误，在for循环中push元素导致迭代器失效,也会导致死循环\nfor(auto it = numbers.begin(); it != numbers.end(); ++it) {\n    numbers.push_back(1);\n}\n```\n\n#### 指针类似迭代器用法\n\n指针也是迭代器，在C++11中利用 `std::begin()` 可以获取数组第一个元素的指针， `std::end()` 获取数组'最后一个元素之后' 的指针，与迭代器的 `end()` 位置相同。\n```C++\nint ia[] = {0,1,2,3,4,5,6,7,8,9};\nint * beg = std::begin(ia);\nint * end = std::end(ia);\nfor(auto it = beg; it != end; ++it){\n    std::cout << *it << \" \";\n}\n```\n\n### C 风格字符串\n\nC风格字符串以空字符作为结束( `/0` )。在字符串的末尾一般会自动加上空字符( `/0` )。\n```C++\nchar *str = \"hello world!\";\n```\n或\n```C++\nchar str[] = \"hello world!\";\n```\n此时会在 `!` 后面自动加上 `/0` 。  \n但是须注意:\n```C++\nchar str[] = {'a', 'b', 'c'};\n```\n虽然这里的 `str` 也是字符串数组，但是内部没有 `/0` ，这就会导致使用查询字符串长度函数 `strlen` 时，会一致沿着 `str` 在内存的位置直到找到 `/0` 才停下来，这也是C风格字符串的漏洞。\n\n","cover":"https://pic.akorin.icu/c++cover.jpg","date":"2025-07-10"},{"title":"Zen Browser默认打开卡顿","tags":["Zen Browser","优化"],"categories":["浏览器"],"author":"akorin","excerpt":"\n**Zen浏览器在全屏使用的时候总有卡顿，最后发现每次启动时，核显的占用率都会达到99%，而Chrome不会**\n\n## 解决方案\n\n- 等待Zen Browser的后续优化\n- 启动Zen Browser时使用高性能（独立显卡启动）：\n\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/20250221164427234.png)\n\n","link":"/posts/zenbrowser","content":"\n**Zen浏览器在全屏使用的时候总有卡顿，最后发现每次启动时，核显的占用率都会达到99%，而Chrome不会**\n\n## 解决方案\n\n- 等待Zen Browser的后续优化\n- 启动Zen Browser时使用高性能（独立显卡启动）：\n\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/20250221164427234.png)\n\n<!-- more -->","cover":"https://pic.akorin.icu/67jja5nl.png","date":"2025-02-21"},{"title":"信号的Matlab编程","tags":["笔记","信号与系统","速通","matlab"],"categories":["笔记"],"author":"akorin","excerpt":"\n记录基于Matlab的有关信号的编程\n\n","link":"/posts/%E4%BF%A1%E5%8F%B7Matlab","content":"\n记录基于Matlab的有关信号的编程\n\n<!-- more -->\n\n## 矩阵运算\n\n- `*`:  普通的矩阵运算，如1xn和mx1的矩阵相乘得到nxm的矩阵\n- `.*`: 对矩阵内的每个元素对应相乘\n- `:  矩阵求转置\n\n## 绘制图像\n### 连续信号\n\n$$\nf(t)=5e^{-0.8t}\\sin(\\pi t),0<t<5\n$$\n\n```matlab\na=5;\nb=0.8;\nt=0:0.01:5;\nx=b*exp(-a*t).*sin(pi*t);\nfigure(1);\nplot(t, x);\n```\n![](https://pic.akorin.icu/20250225210740529.png)\n\n### 离散信号\n\n$$\nf(t)=2(0.8)^{k},-5<k<5\n$$\n\n```matlab\nc=2;\nd=0.8;\nk=-5:5;\ny=c*(0.8).^k;\nfigure(2);\nstem(k, y);\n```\n\n![](https://pic.akorin.icu/20250225210818824.png)\n\n\n```matlab\nt=0:0.01:5;\n```\n取值范围从0到5，且步长取0.01，当省略步长，则默认为1\n\n```matlab\nx=b*exp(-a*t).*sin(pi*t);\n```\n与括号相邻的乘除（*或/）前面都要加点号（.*或./）\n\n:::warning\n\n矩阵和矩阵之间对应的元素之间的运算，在运算符(*、/、^)前也要加点号(.*、./、.^)\n\n:::\n\n\n### 函数\n\n- `plot(t,x);` 绘制连续曲线图像\n- `stem(k,y);` 绘制离散图像\n- `ezplot(表达式);` 绘制使字符表达式等于0的隐函数曲线，无需准备数据\n- `figure(n);` 简历画布\n- `subplot(a,b,c);` 将画布分为a行b列并在c块上绘制\n\n## 利用卷积与变换（拉氏变换、Z变换）求解\n### 拉普拉斯变换\n\n计算\n$$\nf_1(t)=e^{-t}\\varepsilon(t),f_2(t)=te^{-\\frac{1}{2}t}\\varepsilon(t)\n$$\n的卷积\n\n```matlab\nsyms t;                     %新建一个符号变量\nt=sym('t','positive');      %设置符号变量的属性：字符串t为符号变量且为正\nfs1=laplace(exp(-t));       %求函数f1的拉氏变换fs1\nfs2=laplace(t*exp(-t));     %求函数f1的拉氏变换fs1\nyt=simplify(ilaplace(fs1*fs2)); %求拉式反变换\nezplot(yt);                     %绘制变换后的图像\n```\n![](https://pic.akorin.icu/20250225211440024.png)\n\n\n### 离散信号Z变换\n\n求函数\n$$\nf(k)=\\cos(ak)\\varepsilon(k)\n$$\n的Z变换\n\n```matlab\nsyms k a;\nk=sym('k','positive');\nf=cos(a*k);\nF=ztrans(f)\n```\n输出：\n```matlab\n(z*(z - cos(a)))/(z^2 - 2*cos(a)*z + 1)\n\n```\n---\n求函数\n\n$$\nF(z)=\\frac{1}{(z+1)^2}\n$$\n\n的逆Z变换\n```matlab\nsyms z;\nF=1/(1+z)^2;\nf=iztrans(F)\n```\n\n输出：\n\n```matlab\nkroneckerDelta(n, 0) + (-1)^n*(n - 1)\n```\n\n### 函数\n\n- `syms`  定义符号变量，即一个自变量，不带入具体数值，是一个字符或字符串，最后的计算结果也不是固定值，而是表达式，\n- `laplace(表达式);` 求拉氏变换，输出一个字符串表达式\n- `ilaplace(表达式);` 求拉氏反变换，输出一个字符串表达式\n- `simplify(表达式);` 将表达式化为最简形式\n- `ztrans(表达式);` 求Z变换，返回一个字符串表达式\n- `iztrans(表达式);` 求逆Z变换，返回一个字符串表达式\n\n## 求卷积（利用变换求）\n\n$$\nf_1(t)=\n\\begin{cases}\n    2,0<t<1 \\\\\n    0,else\n\\end{cases},\nf_2(t)=\n\\begin{cases}\n    t,0<t<2 \\\\\n    0,else\n\\end{cases}\n$$\n用MATLAB画出 $f_1(t)*f_2(t)$\n\n```matlab\nt1=0:0.001:1;\nt2=0:0.001:2;\nft1=2*rectpuls(t1-0.5,1);\nft2=t2;\nft3=0.001*conv(ft1,ft2);\nt3=0:0.001:3;\nplot(t3,ft3);\ntitle('ft1(t)*ft2(t)')\n```\n![](https://pic.akorin.icu/20250225214019300.png)\n\n:::warning\nmatlab用conv函数求卷积时，要在前面乘上采样间隔才正确\n:::\n\n求\n$$\nx_1(k)=\\sin(k),0\\le k\\le 10 \\quad x_2(k)=0.8^k,0\\le k\\le 15\n$$\n的卷积\n```matlab\nk1=0:10;k2=0:15;\nx1=sin(k1);\nx2=0.8.^k2;\ny=conv(x1,x2);\nk=0:25;\nsubplot(3, 1, 1);stem(k1,x1);\nsubplot(3, 1, 2);stem(k2,x2);\nsubplot(3, 1, 3);stem(k,y);\n```\n![](https://pic.akorin.icu/20250225215129580.png)\n\n```matlab\nx2=0.8.^k2;  \nx2=0.8^k2;  %[!code error]\n```\n由于k2是一个矩阵，不能直接用运算符与之做运算，需要在运算符前加一个点号表明将矩阵的每个元素分别做运算\n\n### 函数\n\n- `rectpuls(t-a,1);` 产生方波信号，宽度为1，中心点移到t=a处，幅度默认为1，在函数前乘系数可得不同幅度，t为时间范围\n- `square(a*t,duty);` 产生**周期**方波信号，a=1时，周期为 $2\\pi$ ，峰值为 $\\pm1$ ；duty为占比单位是%，取0-100\n- `conv(ft1,ft2);` 求这两个函数的卷积结果\n\n:::warning\n\nMatlab中的卷积函数conv(f1,f2)不区分离散和连续，都按照离散的形式来计算\n\n:::\n\n## 绘制零极点图\n### 连续系统\n\n$$\nH(s)=\\frac{s^2+4s+3}{s^4+3s^3+4s^2+6s+4}\n$$\n\n```matlab\nb=[1 4 3];          %分子系数矩阵，且为高次向低次\na=[1 3 4 6 4];      %分母系数矩阵\nsys=tf(b,a);\npzmap(sys);\nsgrid;\nzap=roots(a);\n```\n![](https://pic.akorin.icu/20250225225143483.png)\n\n### 离散系统\n\n$$\nH(z)=\\frac{z^{-1}+2z^{-2}+z^{-3}}{1-0.5z^{-1}-0.005z^{-2}+0.3z^{-3}}\n$$\n\n```matlab\nb=[1 2 1];\na=[1 -0.5 -0.005 0.3];\nfigure(1);\nzplane(b,a);\ntitle('零极点分布图');\nnum=[0 1 2 1];\nden=[1 -0.5 -0.005 0.3];\nh=impz(num,den);\nfigure(2);\nstem(h,'.');\ntitle('冲激响应图');\n[H,w]=freqz(num,den);\nfigure(3);\nplot(w/pi,abs(H));\ntitle('幅频响应');\n```\n\n<div class=\"flex flex-col\">\n\n<div class=\"flex grid-cols-2 justify-center items-center\">\n\n![](https://pic.akorin.icu/20250225235445908.png)\n\n![](https://pic.akorin.icu/20250225235457967.png)\n\n![](https://pic.akorin.icu/20250225235507923.png)\n\n</div>\n\n</div>\n\n```matlab\nstem(h,'.');\n```\nh是要绘制的离散数据；'.'表示一个字符串，指定绘制数据点的标记样式\n\n### 函数\n\n- `tf(b,a);` 生成系统函数，b为分子系数向量，a为分母系数向量\n- `pzmap(sys);` 绘制连续系统函数sys的零极点图\n- `sgrid;` 绘制极坐标网格\n- `zap=roots(a);` 求出零极点\n- `zplane(b,a);` 绘制离散系统零极点分布图，分子不含常数项\n- `h=impz(num,den);` 计算和绘制离散时间系统的单位脉冲响应（冲激响应），分子包含常数项\n- `[H,w]=freqz(num,den);` 求频率响应，分子包含常数项，结果有幅值及对应的角频率\n\n## 求响应（已知系统函数）\n### 连续函数\n\n已知\n\n$$\nH(s)=\\frac{1}{s^3+2s^2+3s+1}\n$$\n\n画出零极点分布，并求单位冲激响应h(t)和频率冲激响应 $H(j\\omega)$，并判断系统是否稳定\n\n```matlab\nnum=[1];\nden=[1 2 3 1];\nsys=tf(num,den);\npoles=roots(den);\n\nfigure(1);\npzmap(sys);\nsgrid;\ntitle('Pole and Zero');\nt=0:0.02:10;\nh=impulse(num,den,t);\n\nfigure(2);\nplot(t,h);\ntitle('impulse Respone');\n[H,w]=freqs(num,den);   \n\nfigure(3);\nplot(w,abs(H));     %横坐标为角频率w，纵坐标为幅度H的绝对值\ntitle('Frequency Spectrum');\n```\n\n<div class=\"flex flex-col\">\n\n<div class=\"flex grid-cols-2 justify-center\">\n\n![](https://pic.akorin.icu/20250227152233684.png)\n\n![](https://pic.akorin.icu/20250227152306961.png)\n\n![](https://pic.akorin.icu/20250227152317892.png)\n\n</div>\n\n</div>\n\n```matlab\nplot(w,abs(H));     %横坐标为角频率w，纵坐标为幅度H的绝对值\n```\n必须要有绝对值才是求幅频响应\n\n### 离散函数\n\n$$\nH(j\\omega)=\\frac{1-j\\omega}{1+j\\omega} \\quad f(t)=\\sin(t)+\\sin(3t)\n$$\n\n```matlab\nt=0:pi/100:4*pi\nb=[-1,1];\na=[1,1];\nft=sin(t)+sin(3*t);\nyt=lsim(b,a,ft,t);\nsubplot(2,1,1);\nplot(t,ft);\ntitle('激励');\nsubplot(2,1,2);\nplot(t,yt);\ntitle('响应');\n```\n![](https://pic.akorin.icu/20250227153908502.png)\n\n### 函数\n\n- `impulse(num,den,t);` 计算和绘制连续时间系统的单位脉冲响应，同时输入也可以最直接接入tf函数定义的传递函数impulse(tf(sys));\n- `lsim(b,a,ft,t);` 模拟和绘制线性时不变对任意输入信号响应\n\n## 根据状态方程求解函数响应\n### 连续系统\n\n$$\n\\begin{bmatrix}\n  \\dot{x}_1(t) \\\\\n  \\dot{x}_2(t)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  -2 & -2 \\\\\n  1 & 0\n\\end{bmatrix}\n\\begin{bmatrix}\n  {x}_1(t) \\\\\n  {x}_2(t)\n\\end{bmatrix}\n+\\begin{bmatrix}\n  10 \\\\\n  0\n\\end{bmatrix}f(t) \n\n$$\n\n$$\n\ny(t)=\\begin{bmatrix}\n  1 & 0\n\\end{bmatrix}\n\\begin{bmatrix}\n  {x}_1(t) \\\\\n  {x}_2(t)\n\\end{bmatrix}\n$$\n\n其中系统输入为：\n\n$$\nf(t)=t\\varepsilon(t)\n$$\n\n初始状态为：\n\n$$\n\\begin{bmatrix}\n  {x}_1(0) \\\\\n  {x}_2(0)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  5 \\\\\n  0\n\\end{bmatrix}\n$$\n\n\n```matlab\n%%%% 求零输入响应 %%%%\nA=[-2 -2;1 0];\nB=[10;0];\nC=[1 0];\nD=[0];\nv0=[5;0];\nt=0:0.01:5;\nX=[0*ones(size(t))];          %输入\n[y,v]=lsim(A,B,C,D,X,t,v0);\nsubplot(2,1,1);\nplot(t,y);\ngrid;\nxlabel('t');\nylabel('y');\ntitle('零输入响应')\n%%%% 求零状态响应 %%%%\nv0=[0;0];\nX=[1*t];                      %输入\n[y,v]=lsim(A,B,C,D,X,t,v0);\nsubplot(2,1,2);\nplot(t,y);\ngrid;\nxlabel('t');\nylabel('y');\ntitle('零状态响应')\n```\n![](https://pic.akorin.icu/20250227160441605.png)\n\n### 离散系统\n\n$$\n\\begin{bmatrix}\n  x_1(k+1) \\\\\n  x_2(k+1)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  0 & 1 \\\\\n  -1 & 1.9021\n\\end{bmatrix}\n\\begin{bmatrix}\n  x_1(k) \\\\\n  x_2(k)\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n  1 \\\\\n  0\n\\end{bmatrix}\n\\begin{bmatrix}\n  f(k)\n\\end{bmatrix}\n\n$$\n$$\n\n\ny(k)=\n\\begin{bmatrix}\n  -1 & 1\n\\end{bmatrix}\n\n\\begin{bmatrix}\n  x_1(k) \\\\\n  x_2(k)\n\\end{bmatrix}\n\n\\quad\n\n\\begin{bmatrix}\n  x_1(0) \\\\\n  x_2(0)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  -10  \\\\\n  -4\n\\end{bmatrix}\n$$\n\n```matlab\nA=[0 1;-1 1.9021];\nB=[1;0];\nC=[-1 1];\nD=[0];\nk=0:1:40;\nv0=[-10;-4];\nX=[1*ones(size(k))];\n[y,v]=dlsim(A,B,C,D,X,v0);\nstem(k,y);\nxlabel('k');\nylabel('y');\ntitle('全响应')\n```\n![](https://pic.akorin.icu/20250227161354348.png)\n\n## 实现Sa信号的采样和恢复\n\n:::tip Sa信号恢复\n\n$$\nf(t)=T_s\\frac{\\omega_c}{\\pi}\\sum\\limits_{n=-\\infty}^{\\infty}f(nT_s)Sa[\\omega_c(t-nT_s)]\n$$\n\n其中 $T_s$ 是采样周期， $\\omega_c$ 是低通滤波器的截止频率，一般取信号的最大频率\n:::\n\ne.g 信号sa(t)作为被采样信号，信号带宽B=1，即信号的最大角频率为1，采样频率 $\\omega_s=2B$ ，此频率下的采样为Nyquist采样，对采样及恢复过程用Matlab进行仿真\n\n```matlab\nws=2;wm=1;\nTs=2*pi/ws;\nN=50;\nn=-N:N;\nnTs=n.*Ts;\nfs=pi*sinc(wm*nTs/pi);\nt=-6*pi:0.001:6*pi;\n%%%% 信号重构 %%%%\nf=fs*1/pi*pi*sinc(1/pi*(ones(length(nTs),1)*t-nTs'*ones(1,length(t))));\nerror=abs(f-pi*sinc(t/pi));\nsubplot(3,1,1);plot(t,pi*sinc(t/pi));\ntitle('Sa函数原始信号')\nsubplot(3,1,2);plot(t,f);\ntitle('恢复信号')\nsubplot(3,1,3);plot(t,error);\ntitle('恢复信号与原信号之间的差值');\n```\n![](https://pic.akorin.icu/20250308212833536.png)\n\n```matlab\nf=fs*1/pi*pi*sinc(1/pi*(ones(length(nTs),1)*t-nTs'*ones(1,length(t))));\n```\n在这段代码中利用矩阵的性质，实现求和\n\n```matlab\nones(length(nTs),1)*t\n```\n这段是nx1的矩阵乘上1xm的矩阵得到nxm的矩阵，此时这个矩阵上的点都是t的点，每一列上对应不同的时间点\n```matlab\nnTs'*ones(1,length(t))\n```\nnTs的转置再乘上ones函数，将nTs矩阵扩展成nxm，此时上面的矩阵都是nTs的点，每一行对应不同的nTs的时间点\n\n两式相减后，每一列就是在单个时间t的点上t-nTs的集合，前面的fs的点数和nTs相同，fs再和后面得到的sinc的矩阵就能得到每个时间t点对应的sinc(t-nTs)的和\n\n### 函数\n\n- `fs=sinc(nTs/pi);` 即辛格函数，sinc函数与Sa函数的数学表达形式相同，有时会区分归一化sinc函数和非归一化sinc函数，而在matlab中`sinc`是归一化sinc函数\n  - 非归一化sinc函数\n  $$\n  sinc(x)=\\frac{\\sin(x)}{x}\n  $$\n  - 归一化sinc函数\n  $$\n  sinc(x)=\\frac{\\sin(\\pi x)}{\\pi x}\n  $$\n\n## 对任意信号的采样频谱分析及恢复\n\n$$\nf(t)=\\sin(2\\pi f_0 t)+ \\frac{1}{3} \\sin(6\\pi f_0 t)\n$$\n\n求该信号的频谱并在采样信号 \n\n$$\nFs>2f_m,F_s=2f_m,Fs<2f_m\n$$\n\n的情况下绘制采样波形以及对采样后的信号进行恢复。其中 $f_0=1Hz$，取最高有限带宽频率 $f_m=5f_0$\n\n```matlab\nclc;clear;close all;\n\n% 信号常量\nf0=1;\nfm=5*f0;\nFs1=5*fm;Fs2=2*fm;Fs3=1*fm;\ntl=-2;th=2;\nt=tl:0.001:th;\nnTs1=tl:1/Fs1:th;\nnTs2=tl:1/Fs2:th;\nnTs3=tl:1/Fs3:th;\n\n% 原始信号和采样信号\n\nf=sin(2*pi*f0*t)+(1/3)*sin(6*pi*f0*t);\n\nfs1=sin(2*pi*f0*nTs1)+1/3.*sin(6*pi*f0*nTs1);\nfs2=sin(2*pi*f0*nTs2)+1/3.*sin(6*pi*f0*nTs2);\nfs3=sin(2*pi*f0*nTs3)+1/3.*sin(6*pi*f0*nTs3);\n\nfigure;\nsubplot(4,1,1);\nplot(t,f);\ntitle('原信号');\n\nsubplot(4, 1, 2);\nstem(nTs1,fs1,'.');\nsubplot(4, 1, 3);\nstem(nTs2,fs2,'.');\nsubplot(4, 1, 4);\nstem(nTs3,fs3,'.');\n\n% fft求各采样信号的频谱\n\nx1=fftshift(fft(fs1));f1=linspace(-Fs1/2,Fs1/2,length(x1));\nx2=fftshift(fft(fs2));f2=linspace(-Fs2/2,Fs2/2,length(x2));\nx3=fftshift(fft(fs3));f3=linspace(-Fs3/2,Fs3/2,length(x3));\n\n% 绘图\n\nfigure;\nsubplot(3, 1, 1);\nstem(f1,2.*abs(x1)/length(x1),'.');\nxlabel('f/Hz');ylabel('幅值');\n\nsubplot(3, 1, 2);\nstem(f2,2.*abs(x2)/length(x2),'.');\nxlabel('f/Hz');ylabel('幅值');\n\nsubplot(3, 1, 3);\nstem(f3,2.*abs(x3)/length(x3),'.');\nxlabel('f/Hz');ylabel('幅值');\n\n% 重建信号并求绘图\n\nF1=fs1*1/Fs1*2*pi*fm/pi*sinc(1/pi*2*pi*fm*(ones(length(nTs1),1)*t-nTs1'*ones(1,length(t))));\nfigure;\nsubplot(311);\nplot(t, F1,'r',t,f,'b');\n\nF2=fs2*1/Fs2*2*pi*fm/pi*sinc(1/pi*2*pi*fm*(ones(length(nTs2),1)*t-nTs2'*ones(1,length(t))));\nsubplot(312);\nplot(t, F2,'r',t,f,'b');\n\nF3=fs3*1/Fs3*2*pi*fm/pi*sinc(1/pi*2*pi*fm*(ones(length(nTs3),1)*t-nTs3'*ones(1,length(t))));\nsubplot(313);\nplot(t, F3,'r',t,f,'b');\n```\n\n\n<div class=\"flex flex-col\">\n<div class=\"flex grid-cols-2 justify-center items-center\">\n\n![](https://pic.akorin.icu/20250310170814974.png)\n\n![](https://pic.akorin.icu/20250310170821224.png)\n\n![](https://pic.akorin.icu/20250310170845805.png)\n\n</div>\n</div>\n\n## 求群时延\n\n```matlab\nclc;clear;close all;\n\nb=[100*2e-9];\na=[22e-6*2e-9,100*2e-9,1];\n\n[h,w]=freqs(b,a);\n\n%% 普通画图：\n\n% figure;\n% subplot(2, 1, 1);\n% loglog(w,20*log10(abs(h)));\n% ylabel('幅值(dB)')\n% xlabel('频率(rad/s)')\n% title('幅频响应');\n% subplot(2, 1, 2);\n% plot(w, 180*angle(h)/pi);\n% axis([1e6,1e8,-180,0]);\n% ylabel('角度')\n% xlabel('频率(rad/s)')\n% title('相频响应');\n\n%% 直接利用freqs生成图更美观\n\nfigure;\nfreqs(b,a);\n\n%% 扩展w的个数，使画图更准确\nfigure;\nw=linspace(w(1),w(end),length(w)*1000);\n[h1,w1]=freqs(b,a,w);\ngroupDelay = -gradient(angle(h1),w1)/360;\ngrid on\n\n%% 生成对x取10为对数的坐标的图\nsemilogx(w,groupDelay)\nylabel('延迟')\nxlabel('频率(rad/s)')\n```\n\n### 函数\n\n- `gradient`: 用法：`[FX,FY] = gradient(F,H)` 或 `Fx = gradient(F,H)` 以H对离散点F求导\n\n```matlab\ngroupDelay = -gradient(angle(h1),w1)/360;\n```\n满足了群时延的定义，即角度对角频率的负导数即为群时延。群时延是系统三大特征之一（另外两个分别是幅频响应和相频响应），群时延标志着信号中的频率分量通过系统的时间。全通系统的作用就是用来对信号中某些频率分量的延时。","cover":"https://pic.akorin.icu/封面3.png","date":"2025-02-25"},{"title":"数字信号处理简记","tags":["笔记","数字信号处理","速通","matlab"],"categories":["笔记"],"author":"akorin","excerpt":"\n主要记录数字信号处理Matlab代码及相关知识\n\n:::warning\n\n默认已学习完信号与系统\n\n:::\n","link":"/posts/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86","content":"\n主要记录数字信号处理Matlab代码及相关知识\n\n:::warning\n\n默认已学习完信号与系统\n\n:::\n<!-- more -->\n\n# 数字信号处理简记\n----\n\n## 0.预备知识\n### 0.1 数字信号处理的过程\n\n<center>\n\n```mermaid\n\nstateDiagram \n  [*] --> 前置滤波器:$$x_a(t)$$\n  前置滤波器 --> A/D变换器\n  A/D变换器 --> 数字信号处理器:$$x(n)$$\n  数字信号处理器 --> D/A变换器:$$y(n)$$\n  D/A变换器 --> 模拟滤波器\n  模拟滤波器 --> [*]:$$y_a(t)$$\n\n```\n</center>\n\n### 0.2 信号的周期\n\n- 离散信号：周期必须为整数，并且当且仅当两个周期信号的周期之比为有理数时，相加之和的信号才为周期信号，此时的和信号周期为它们的最小公倍数\n- 连续信号：周期可以是整数、无理数、有理数，且当且仅当两个周期信号的周期之比为有理数时，它们的和信号才是周期信号，且和信号周期为它们的最小公倍数\n\n如 $\\sin(n)$，由于$N=\\frac{2\\pi}{n} \\neq R$ 不是周期信号\n$\\sin(\\pi n)$，由于$N=\\frac{2\\pi}{n\\pi}=R$ 是周期信号\n\n### 0.3 偶信号和奇信号\n\n任意信号都可以分解成偶信号和奇信号之和\n\n- 奇信号($Od\\{x[n]\\}$) $=\\frac{1}{2}x[n]-x[-n]$\n- 偶信号($Ev\\{x[n]\\}$) $=\\frac{1}{2}x[n]+x[-n]$\n\n### 0.4 序列的基本运算\n\n- 移位  $x(n\\pm m)$\n- 翻褶  $x(-n)$\n- 和  $x(n)+y(n)$\n- 积  $x(n)\\bullet y(n)$\n- 累加  $y(n)=\\sum\\limits_{k=-\\infty}^\\infty x(k)$\n- 差分运算  $\\triangle x(n)=x(n+1)-x(n) \\\\ \\triangle x(n)=x (n)-x(n-1)$ \n\n\n### 0.5 序列的能量和功率\n\n- 能量：$E_\\infty=\\lim\\limits_{N \\to \\infty}\\sum\\limits_{n = -N}^\\infty|x[n]|^2=\\sum\\limits_{n = -\\infty}^\\infty|x[n]|^2$\n- 功率：$P_\\infty=\\lim\\limits_{N \\to \\infty}\\frac{1}{2N+1}\\sum\\limits_{n = -N}^\\infty|x[n]|^2$\n\n---\n\n- 能量信号：能量有限，功率为0\n- 功率信号：功率有限，能量数值无界\n- 非功非能信号：不满足上述两个条件的信号\n\n:::warning\n\n因此说一个序列要么是功率信号要么是能量信号是错误的\n\n:::\n\n### 0.6 离散时间(傅里叶变换DTFT)\n\n$X(e^{j\\omega})=DTFT[x(n)]=\\sum\\limits_{n=-\\infty}^\\infty x(n)e^{-j\\omega n}$\n\n即将$z$换成$e^{j\\omega}$\n\n:::tip Tips\n\n时域周期->频域离散\n\n时域离散->频域周期\n\n时域非周期->频域连续\n\n时域连续->频域非周期\n\n:::\n\n可以看出 $e^{j\\omega n}$ 是以 $2\\pi$ 为周期的正交周期函数\n\n反变换：IDTFT\n\n## 1.离散傅里叶变换(DFT)\n### 1.1 周期序列的傅里叶级数对——离散傅里叶级数(DFS)\n\n$$\n\n\\tilde{X}(k)=\\sum\\limits_{n=0}^{N-1}\\tilde{x}(n)e^{-j\\frac{2\\pi}{N}nk}\n\n$$\n\n> IDFS:\n\n$$\n\n\\tilde{x}(n)=\\frac{1}{N}\\sum\\limits_{k=0}^{N-1}\\tilde{X}(k)e^{j\\frac{2\\pi}{N}nk}\n\n$$\n\n其中  $e^{j\\frac{2\\pi}{N}nk}$ 称为旋转因子，$\\tilde{x}$ 上的波浪线代表其为周期函数\n\n在数字信号处理中一般使用符号 $W_N=e^{j\\frac{2\\pi}{N}}$，其中N为离散序列的周期\n故有：\n\n$$\n\nW_N^k=e^{j\\frac{2\\pi}{N}k}\n\n$$\n$$\n\nW_N^{nk}=e^{j\\frac{2\\pi}{N}nk}\n\n$$\n\n$$\n\\cdots\n$$\n\n> $W_N$ 的性质：\n> - 共轭对称性：$W_N^n=(W_N^{-n})^*$\n> > 在复变中，指数型复数取共轭即在 $j$ 前加负号\n> - 周期性：$W_N^n=W_N^{n+iN}$\n> - 可约性：$W_N^{in}=W_{N/i}^{n}$ , $W_{Ni}^{in}=W_N^n$\n> - 正交性：\n$$\n\\frac{1}{N}\\sum\\limits_{k=0}^{N-1}W_N^{nk}(W_N^{mk})^*=\\frac{1}{N}\\sum\\limits_{k=0}^{N-1}W_N^{(n-m)k}=\\begin{cases}\n    1\\quad n-m=iN\\\\\n    0\\quad n-m\\neq iN\n\\end{cases}\n$$\n\n### 1.2 DFS与DTFT的关系\n\n$\\tilde{X}(k)$ 这一周期序列可以看作是 $\\tilde{x}(n)$ 的一个周期 $x(n)$ 的z变换 $X(z)$ 在z平面单位圆上按等间隔角 $\\frac{2\\pi}{N}$ 抽样得到，或是 $x(n)$ 的傅里叶变换 $X(e^{j\\omega})$ 在 $[0,2\\pi)$ 上的N点等间隔采样，抽样间隔为 $\\frac{2\\pi}{N}$\n\n$$\n\n\\tilde{X}(k)=X(z)|_{z=e^{j\\frac{2\\pi}{N}k}}\n\n$$\n\n$$\n\n\\tilde{X}(k)=X(e^{j\\omega})|_{\\omega=\\frac{2\\pi}{N}k}\n\n$$\n\n省流就是在z平面或者在频谱上进行抽样\n\ne.g：计算 1 1 1 1 1 的5点DFS：\n\n$$ \n\\tilde{X}(k) = \\sum_{n=0}^{N-1} \\tilde{x}(n) e^{-j \\frac{2\\pi}{N} nk} \n$$\n$$ \n\\tilde{X}(0) = \\sum_{n=0}^{4} \\tilde{x}(n) e^{-j \\frac{2\\pi}{5} n \\cdot 0} = \\sum_{n=0}^{4} 1 \\cdot 1 = 5 \n$$\n\n$$\n \\tilde{X}(1) = \\sum_{n=0}^{4} \\tilde{x}(n) e^{-j \\frac{2\\pi}{5} n \\cdot 1} = \\sum_{n=0}^{4} e^{-j \\frac{2\\pi}{5} n}\n$$\n\n$$\n \\tilde{X}(1) = 1 + e^{-j \\frac{2\\pi}{5}} + e^{-j \\frac{4\\pi}{5}} + e^{-j \\frac{6\\pi}{5}} + e^{-j \\frac{8\\pi}{5}} = 0 \n$$\n（等比数列的求和公式）\n\n$$\n \\tilde{X}(2)=\\cdots \\\\\n \\tilde{X}(3)=\\cdots \\\\\n \\cdots\n$$\n\n最后可得结果：5 0 0 0 0\n\n### 1.3 离散傅里叶变换DFT\n\n","cover":"https://pic.akorin.icu/5jxcqhea.png","date":"2025-02-19"},{"title":"数字信号处理Matlab编程","tags":["笔记","数字信号处理","matlab"],"categories":["笔记"],"author":"akorin","excerpt":" \n记录数字信号处理有关的Matlab代码\n\n","link":"/posts/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86Matlab","content":" \n记录数字信号处理有关的Matlab代码\n\n<!-- more -->\n\n# 数字信号处理Matlab\n\n---\n\n## 数字滤波器的设计方法\n\n:::warning\n\n有关数字滤波的函数输入都是归一化的频率而不是角频率，有关模拟滤波的函数输入都是角频率\n\n:::\n\n有两种数字滤波器：\n- iir   无限长冲激响应滤波器\n- fir   有限长冲激响应滤波器\n\niir 的设计方法：\n- 冲激响应不变法\n  - 两种模拟滤波器：巴特沃斯滤波器、切比雪夫滤波器\n  - 不能设计高通和带阻滤波器\n- 双线性变换法\n\nfir 的设计方法：\n- 窗函数法\n  - 须确保窗长度为奇数，即确保阶数为偶数\n- 频率取样法\n\n:::tip 带通滤波器的中心频率计算\n带通滤波器下限频率和上限频率的几何平均值\n$$\n\\omega_0=\\sqrt{\\omega_{p_1}\\omega_{p_2}}\n$$\n:::\n\n:::tip 带通滤波器的上下截止频率计算\n近似为阻带截止频率和通带截止频率和的一半\n$$\n\\omega_c=\\frac{\\omega_s+\\omega_p}{2}\n$$\n:::\n\n\n### 所需的函数\n\n#### `buttord` \n\n生成对应标准型巴特沃斯的阶数和截止频率\n\n> 语法：\n- `[n,Wn] = buttord(Wp,Ws,Rp,Rs)`\n- `[n,Wn] = buttord(Wp,Ws,Rp,Rs,'s')`\n- `[n,Wn] = buttord(Wp,Ws,Rp,Rs,'z')`\n\n> 参数：\n- Wp: 通带截止频率，模式为数字滤波器时，输入需归一化；模式为模拟滤波器时，输入单位是rad/s\n- Ws: 阻带截止频率，模式为数字滤波器时，输入需归一化；模式为模拟滤波器时，输入单位是rad/s\n- Rp: 通带衰减\n- Rs: 阻带衰减\n- 's': 设定为模拟类型的滤波器，缺省则默认为数字滤波器\n- 'z': 设定为数字类型的滤波器，缺省则默认为数字滤波器\n\n> 返回值：\n- n:  返回巴特沃斯的最低阶数\n- Wn: 返回截止频率的标量（-3dB位置）\n\n\n:::warning 归一化\n输入范围为0~1，其中1对应 $\\pi$ 弧度/采样点，即最大频率或最小采样频率/2（奈奎斯特频率）\n\n归一化频率计算公式：\n$$\nf_{norm}=\\frac{f}{\\frac{fs}{2}}=\\frac{f}{f_{Nyquist}}\n$$\n归一化的单位是Hz/样本，直接乘上 $\\pi$ 转化成弧度则为：rad/样本，即\n$$\n\\omega = f_{norm} \\times \\pi\n$$\n本质上是一个比例，不是物理上确切的单位\n:::\n\n:::tip 归一化频率转化为原始频率\n对于f 频率来说：\n$$\nf=f_{norm} \\times \\frac{fs}{2}\n$$\n对于 $\\omega$ 角频率来说：\n$$\n\\omega = 2\\pi f= 2\\pi\\times f_{norm}\\times \\frac{f_s}{2} =2\\pi \\times  \\frac{\\omega_{norm}}{\\pi} \\times \\frac{f_s}{2}=\\omega_{norm} \\times f_s\n$$\n:::\n\n#### `buttap`\n\n> 语法：\n- `[z,p,k] = buttap(n)`\n\n> 参数：\n- n:  巴特沃斯滤波器阶数\n\n> 返回值：\n- z:  模拟滤波器的极点\n- p:  模拟滤波器的零点\n- k:  模拟滤波器的增益\n\n\n#### `zp2tf`\n\n将零极点增益参数转化为传递函数的形式\n\n> 语法：\n- `[b,a] = zp2tf(z,p,k)`\n\n> 参数：\n- z:  模拟滤波器的极点\n- p:  模拟滤波器的零点\n- k:  模拟滤波器的增益\n\n> 返回值：\n- b:  传递函数分子的系数\n- a:  传递函数分母的系数\n\n#### `freqs`\n\n求出模拟滤波器的频率响应\n\n> 语法：\n- `h = freqs(b,a,w)`\n- `[h,wout] = freqs(b,a,n)`\n- `freqs(___)`\n\n> 参数：\n- b:  传递函数分子的系数\n- a:  传递函数分母的系数\n- w（可选）:  角频率w处计算复频率响应\n- n（可选）:  使用n个频率点计算h并在wout中返回对应角频率，缺省默认是200\n\n> 返回值：\n- h:  返回由b和a指定的模拟滤波器在角频率w处计算得到的复频率响应\n- wout: 返回使用n个频率点计算h得到的角频率\n- freqs(___): 不带返回值参量，直接在窗口中以角频率的函数形式绘制幅频响应曲线和相频响应曲线\n\n\n#### `freqz`\n\n求出模拟滤波器的频率响应\n\n> 语法：\n- `h = freqz(b,a,w)`\n- `[h,w] = freqz(b,a,n)`\n- `[h,w] = freqz(b,a,n,fs)`\n- `[h,w] = freqz(b,a,n,\"whole\")`\n- `[h,w] = freqz(b,a,n,\"whole\",fs)`\n- `freqz(___)`\n\n> 参数：\n- b:  传递函数分子的系数\n- a:  传递函数分母的系数\n- w（可选）:  **归一化**的角频率w处计算复频率响应\n- n（可选）:  使用n个频率点计算h并在wout中返回对应角频率，缺省默认是200\n- \"whole\"（可选）: 返回整个单位圆n个采样点的频率响应，即返回(0~2 $\\pi$ 的采样点，缺省时返回的是0~ $\\pi$ 的采样点)\n\n> 返回值：\n- h:  返回由b和a指定的模拟滤波器在角频率w处计算得到的复频率响应\n- wout: 返回使用n个频率点计算h得到的角频率\n- freqs(___): 不带返回值参量，直接在窗口中以角频率的函数形式绘制幅频响应曲线和相频响应曲线\n\n\n#### `lp2lp`\n标准的巴特沃斯模拟低通滤波器原型转换为具有指定截止频率的模拟低通滤波器。通过zp2tf生成的标准巴特沃斯低通滤波器的截止频率通常是1rad/s，因此需要转换成所需要的\n\n> 语法：\n- `[bt,at] = lp2lp(b,a,Wo)`\n- `[At,Bt,Ct,Dt] = lp2lp(A,B,C,D,Wo)`\n\n> 参数：\n- b: 转换前的传递函数分母的系数\n- a: 转换前的传递函数分子的系数\n- wo: 新的滤波器截止频率\n\n> 返回值：\n- bt: 转换后的新的传递函数分母的系数\n- at: 转换后的新的传递函数分子的系数\n\n#### `lp2hp`\n\n转换成特定截止频率的高通滤波器\n\n#### `lp2bp`\n转换成特定截止频率的带通滤波器\n\n\n> 语法：\n- `[B1,A1]=lp2bp(num1, den1, Wo, bw)`\n\n> 参数：\n- Wo: 带宽的中心频率\n  - 一般是几何平均\n\n:::warning\n与fir带通数字滤波器相比，lp2bp的Wo传输的值是通带的中心频率，而fir1中的Wn传输的是上下通带的截止频率\n:::\n\n#### `lp2bs`\n\n转换成特定截止频率的带阻滤波器\n\n> 语法：\n- `[bt,at] = lp2bs(b,a,Wo,Bw)`\n\n> 参数：\n- Wo: 阻带的中心频率\n  - 一般是几何平均\n\n#### `impinvar`\n\n脉冲响应不变法将模拟滤波器转换为数字滤波器\n\n> 语法：\n- `[bz,az] = impinvar(b,a,fs)`\n\n> 参数：\n- b: 模拟滤波器传递函数的分母\n- a: 模拟滤波器传递函数的分子\n- fs: 采样频率\n\n> 返回值：\n- bz: 数字滤波器传递函数的分母\n- az: 数字滤波器传递函数的分子\n\n#### `bilinear`\n\n双线性变换法将模拟滤波器转换为数字滤波器\n\n> 语法：\n- `[zd,pd,kd] = bilinear(z,p,k,fs)`\n- `[numd,dend] = bilinear(num,den,fs)`\n\n> 参数：\n- z:  模拟滤波器的极点\n- p:  模拟滤波器的零点\n- k:  模拟滤波器的增益\n- fs: 采样频率\n- num:  模拟滤波器传递函数分母\n- den:  模拟滤波器传递函数分子\n\n> 返回值：\n- zd: 数字域的极点\n- pd: 数字域的零点\n- kd: 数字域的增益\n- numd: z域传递函数分母\n- dend: z域传递函数分子\n#### `cheb1ord`\n\n生成对应的标准型I型切比雪夫滤波器\n\n> 语法：\n- `[n,Wn] = cheb1ord(Wp,Ws,Rp,Rs)`\n- `[n,Wn] = cheb1ord(Wp,Ws,Rp,Rs,'s')`\n- `[n,Wn] = cheb1ord(Wp,Ws,Rp,Rs,'z')`\n\n> 参数：\n- Wp: 通带截止频率，模式为数字滤波器时，输入需归一化；模式为模拟滤波器时，输入单位是rad/s\n- Ws: 阻带截止频率，模式为数字滤波器时，输入需归一化；模式为模拟滤波器时，输入单位是rad/s\n- Rp: 通带衰减\n- Rs: 阻带衰减\n- 's': 设定为模拟类型的滤波器，缺省则默认为数字滤波器\n- 'z': 设定为数字类型的滤波器，缺省则默认为数字滤波器\n\n> 返回值：\n- n:  对应切比雪夫滤波器的阶数\n- Wn: 对应的截止频率\n\n#### `ceil`\n\n> 语法：\n- `Y = ceil(X)`\n\n> 参数：\n- X: 元素值，也可以是数组\n\n> 返回值：\n- Y: X的四舍五入值，或者数组里的每个元素四舍五入后的值\n\n:::warning \n窗的长度=fir滤波器的阶数+1\n:::\n\n#### `triang`\n\n三角窗\n\n#### `blackman`\n\n布莱克曼窗\n\n#### `hamming`\n\n海明窗\n\n#### `fir1`\n\n基于窗函数的 FIR 滤波器设计\n\n> 语法：\n- `b = fir1(n,Wn)`\n- `b = fir1(n,Wn,ftype)`\n- `b = fir1(___,window)`\n\n> 参数：\n- n:  fir滤波器的阶数。对于**高通**和**带阻**滤波器，fir1 始终使用偶数阶滤波器。此时阶数必须是偶数，因为奇数阶对称 FIR 滤波器在奈奎斯特频率下必须具有零增益。如果为高通或带阻滤波器指定奇数 n，则 fir1 将 n 增加 1。\n- Wn: 通带截止频率\n- ftype:  滤波器类型，缺省默认为低通滤波器\n  - 'high'\n  - 'low'\n  - 'bandpass'\n  - 'stop'\n- window: 窗函数类型，缺省默认为汉明窗\n\n#### `mod`\n\n> 语法：\n- `b = mod(a,m)`\n\n> 参数：\n- a:  被除数\n- m:  除数\n\n> 返回值：\n- b:  余数\n\n### 数字滤波器设计\n\n:::details 完整代码\n\n:::code-group\n\n<<< @/code/matlab/digitalSignalProcessing/iir_bp.m{matlab}[iir带通设计]\n<<< @/code/matlab/digitalSignalProcessing/fir_bs.m{matlab}[fir带阻设计]\n<<< @/code/matlab/digitalSignalProcessing/bs.m{matlab}[fir、iir带阻设计]\n\n:::\n\n<div class=\"flex flex-col\">\n<div class=\"flex grid-cols-2 justify-center items-center\">\n\n![](https://pic.akorin.icu/20250306165711447.png)\n\n![](https://pic.akorin.icu/20250306165728680.png)\n\n</div>\n</div>\n\n<div class=\"flex flex-col\">\n<div class=\"flex grid-cols-2 justify-center items-center\">\n\n![](https://pic.akorin.icu/20250306165837959.png)\n\n![](https://pic.akorin.icu/20250306165846804.png)\n\n</div>\n</div>\n\n![](https://pic.akorin.icu/20250306165536593.png)\n\n## 生成各种信号的设计方法\n\n:::warning\n\n需要注意每个生成波形的函数的输入都是角频率乘时间即输入都是 $\\omega\\times t$\n\n:::\n\n### 所需函数\n\n#### `rand`\n\n返回一个在区间 (0,1) 内均匀分布的随机数\n\n> 语法：\n- `x=rand(n)`\n- `x=rand(a,n)`\n\n> 参数：\n- a:  序列矩阵的维度\n- n:  序列矩阵长度，当a缺省时生成nxn的随机数矩阵\n\n> 返回值：\n- x:  输出的序列\n\n#### `randn`\n\n返回一个从标准正态分布中得到的随机标量，均值为0方差为1\n\n> 语法：\n- `x=randn(n)`\n- `x=randn(a,n)`\n\n> 参数：\n- a:  序列矩阵的维度\n- n:  序列矩阵长度，当a缺省时生成nxn的随机数矩阵\n\n> 返回值：\n- x:  输出的序列\n\n#### `rectpuls`\n\n生成方波信号\n\n> 语法：\n- `y = rectpuls(t0,w)`\n\n> 参数：\n- t0: 方波中心点\n- w:  宽度\n\n#### `square`\n\n生成周期方波信号\n\n> 语法：\n- `x = square(w*t,duty)`\n\n> 参数：\n- w*t:  w为方波信号的角速度，对应的周期为 $T=\\frac{2\\pi}{\\omega}$ ，t为时间参数（一维向量）\n- duty: 方波信号的周期\n\n> 返回值：\n- x:  对应时间参数t的一系列幅值，幅值范围为-1~1\n\n#### `sawtooth`\n\n生成锯齿波信号\n\n> 语法：\n- `x = sawtooth(w*t,xmax)`\n\n> 参数：\n- xmax: 峰值位置范围0~1，当设置为0.5时，生成标准三角波，缺省时，xmax默认为1\n\n### 生成常用波形\n\n:::details 完整代码\n\n:::code-group\n\n<<< @/code/matlab/digitalSignalProcessing/impulse_t.m{matlab}[阶跃响应]\n<<< @/code/matlab/digitalSignalProcessing/square_duty.m{matlab}[方波设计]\n<<< @/code/matlab/digitalSignalProcessing/sawtooth_t.m{matlab}[锯齿波/三角波设计]\n\n:::\n\n![](https://pic.akorin.icu/20250306191320790.png)\n\n<div class=\"flex flex-col\">\n<div class=\"flex grid-cols-2 justify-center items-center\">\n\n![](https://pic.akorin.icu/20250306191224974.png)\n\n![](https://pic.akorin.icu/20250306191232702.png)\n\n</div>\n</div>\n\n<div class=\"flex flex-col\">\n<div class=\"flex grid-cols-2 justify-center items-center\">\n\n![](https://pic.akorin.icu/20250306191351382.png)\n\n![](https://pic.akorin.icu/20250306191358180.png)\n\n</div>\n</div>\n\n\n\n\n## 求解各种系统函数的阶跃响应、冲激响应\n### 所需函数\n\n#### `impulse`\n\n求解连续系统的冲激响应\n\n> 语法：\n- `impulse(sys)`\n- `impulse(sys,Tfinal)`\n- `impulse(sys,t)`\n- `y = impulse(sys)`\n- `[y,t] = impulse(sys)`\n\n> 参数：\n- sys:  tf函数生成的系统，也可以将分母系数b、分子系数a填入其中\n- Tfinal: 求解0到Tfinal这段时间内的冲激响应\n- t:  求解t这段设定的时间向量内的冲激响应\n\n> 返回值：\n- y:  求解冲激响应的结果\n- t:  求解的结果对应的时间点\n- \n#### `dimpulse`\n\n求解离散系统的冲激响应\n\n> 语法：\n- `dimpulse(sys)`\n- `dimpulse(sys,Tfinal)`\n- `dimpulse(sys,t)`\n- `y = dimpulse(sys)`\n\n> 参数：\n- sys:  tf函数生成的系统，也可以将分母系数b、分子系数a填入其中\n- Tfinal: 求解0到Tfinal这段时间内的冲激响应\n- t:  求解t这段设定的时间向量内的冲激响应\n\n> 返回值：\n- y:  求解冲激响应的结果\n- t:  求解的结果对应的时间点\n\n#### `impz`\n\n求解数字滤波器系统的冲激响应\n\n#### `step`\n\n求解连续时间系统阶跃响应\n\n> 语法：\n- `step(sys)`\n- `step(sys,Tfinal)`\n- `step(sys,t)`\n- `y = step(sys,t)`\n- `[y,t] = step(sys)`\n\n> 参数：\n- sys:  tf函数生成的系统，也可以将分母系数b、分子系数a填入其中\n- Tfinal: 求解0到Tfinal这段时间内的阶跃响应\n- t:  求解t这段设定的时间向量内的阶跃响应\n\n> 返回值：\n- y:  求解阶跃响应的结果\n- t:  求解的结果对应的时间点\n\n#### `dstep`\n\n求解离散时间系统的阶跃响应\n\n> 语法：\n- `[Y,X] = dstep(b,a)`\n- `[Y,X] = dstep(b,a,t)`\n\n#### `lsim`\n\n求解连续时间系统的全响应\n\n> 语法：\n- `y = step(sys,t)`\n- `y = step(b,a,t)`\n- `[y,t] = step(sys)`\n- `[y,t] = step(b,a)`\n\n> 参数：\n- sys:  tf的连续系统\n- t:    时间范围\n- b:    系统函数的分子\n- a:    系统函数的分母\n\n#### `dlsim`\n\n求解离散时间系统的全响应\n\n> 语法：\n- `[Y,X] = dlsim(b,a,x)`\n- `Y = dlsim(b,a,x)`\n\n\n### 求出冲激响应和阶跃响应以及全响应\n（连续系统）求该系统的冲激响应、阶跃响应以及输入为方波的全响应\n$$\nH(s)=\\frac{1}{LCs^2+RCs+1}\n$$\n\n（离散系统）已知一个IIR数字低通滤波器的系统函数为\n\n$$\nH(z)=\\frac{0.1321+0.3963z^{-1}+0.3963z^{-2}+0.1321z^{-3}}{1-0.34319z^{-1}+0.60439z^{-2}-0.20407^{-3}}\n$$\n\n\n:::details 完整代码\n:::code-group\n\n<<< @/code/matlab/digitalSignalProcessing/impulse_step.m{matlab}[连续系统]\n<<< @/code/matlab/digitalSignalProcessing/impz_dlsim.m{matlab}[离散系统]\n\n\n\n:::\n\n<div class=\"flex flex-col\">\n<div class=\"flex grid-cols-2 justify-center items-center\">\n\n![](https://pic.akorin.icu/20250306191115726.png)\n\n![](https://pic.akorin.icu/20250306191125325.png)\n\n![](https://pic.akorin.icu/20250307154416448.png)\n\n</div>\n</div>\n\n![](https://pic.akorin.icu/20250307160823893.png)\n\n## 转换系统函数的类型\n### 所需函数\n\n#### `tf2sos`\n\n将直接型滤波器转化成级联型\n\n> 语法：\n- `[sos,g] = tf2sos(b,a)`\n\n> 参数：\n- b:  传递函数的分母\n- a:  传递函数的分子\n\n> 返回值：\n- sos:  级联型的传递函数形式\n- g:  增益\n\n\n#### `residue`\n\n连续域的分式展开（部分分式分解）\n\n> 语法：\n- `[r,p,k] = residue(b,a)`\n\n> 参数：\n- b:  传递函数分母\n- a:  传递函数分子\n\n> 返回值\n- r:  新的并联型传递函数的一系列分子\n- p:  传递函数的一系列极点\n- k:  传递函数的冲激项\n\n#### `residuez`\n\nz域的部分分式展开（部分分式分解）\n\n> 语法：\n- `[r,p,k] = residuez(b,a)`\n\n> 参数：\n- b:  传递函数分母\n- a:  传递函数分子\n\n> 返回值\n- r:  新的并联型传递函数的一系列分子\n- p:  传递函数的一系列极点\n- k:  传递函数的冲激项\n\n### 将直接型系统函数转换成级联型和并联型\n\n$$\nH(s)=\\frac{s^4-2s^3+30s^2+14s+5}{5s^4+4s^3+4s^2-2s-1}\n$$\n\n<<< @/code/matlab/digitalSignalProcessing/res_sos.m{matlab}[转换]\n\n\n<div class=\"flex flex-col\">\n<div class=\"flex grid-cols-2 justify-center items-center\">\n\n![](https://pic.akorin.icu/20250307193448574.png)\n\n![](https://pic.akorin.icu/20250307193512079.png)\n\n</div>\n</div>\n\n根据上图的两个结果可得：\n$$\nH(s)=0.2\\frac{s^2-2.4647s+30.9839}{s^2-0.1964s-0.1714} \\cdot \\frac{s^2+0.4647s+0.1614}{s^2+0.9964s+1.1671}\n$$\n\n$$\nH(s)=\\frac{s+1.0378+1.9180j}{s+0.4982-0.9586j}+\\frac{s+1.0378-1.9180j}{j+0.4982+0.9586j}+\n$$\n$$\n\\frac{s-2.4360}{s-0.5237}+\\frac{s+0.9240}{s+0.3272}+0.2\n$$\n## 求解频谱\n### 傅里叶变换和反变换\n\n在matlab中求某变量的积分，可以用到矩阵乘法\n\n有一非周期方波信号x(t)的脉冲宽度为1ms，信号持续时间为2ms，在0~2ms区间外信号为0。试求其含有20次谐波的信号的频谱特性。求其逆变换并与原时间信号的波形进行比较。\n\n:::details 完整代码\n\n<<< @/code/matlab/digitalSignalProcessing/fuliye.m{matlab}[傅里叶变化]\n\n:::\n\n![](https://pic.akorin.icu/20250307182242524.png)\n\n```matlab\nf=-20/2e-3:40/2e-3/N:20/2e-3;   % 20次谐波的频谱范围\n```\n这里是计算出20次谐波的频谱范围，取N次谐波内的频谱公式为：\n$-N\\times\\frac{1}{T}$ ~ $N\\times\\frac{1}{T}$\n\n其中T为信号的有效时间范围\n\n```matlab\nX=x*exp(-j*t'*w)*dt;            % 傅里叶变换\n```\n```matlab\ny=1/pi*X*exp(j*w'*t)*dw;        % 逆傅里叶变换\n```\n这两步都实现了积分\n```matlab\nt'*w\n```\n这个操作是将t进行转置后与w矩阵相乘，最后得到(n+1)x(n+1)的矩阵，（n+1是因为首尾的点都算进去没有减掉）。这个矩阵可以看作是每个频域点上对应的所有时间对应值的集合，前面的x是1x(n+1)的矩阵，相乘之后得到的结果就是每个频域点上所有时间对应值之和，相当于计算了积分（matlab是离散点计算本质还是求和）\n\n通过这个原理可以解决所有含有积分符号的公式\n\n\n### 计算两个序列的互相关\n\n互相关函数:\n$$\nr_{xy}(m)=\\sum\\limits^\\infty_{n=-\\infty}x(n)y(n-m)\n$$\n\n在matlab中可以先把两个序列分别用fft函数求其频谱，在频域下前一个序列的共轭与另一个序列相乘，得到的结果再ifft后循环移位可得到它们的结果\n\n:::details 完整代码\n\n<<< @/code/matlab/digitalSignalProcessing/fft_rr.m{matlab}[求两个不同序列的互相关]\n\n:::\n\n![](https://pic.akorin.icu/20250327212742259.png)","cover":"https://pic.akorin.icu/封面4.png","date":"2025-03-03"},{"title":"通信原理简记","tags":["笔记","通信原理"],"categories":["笔记"],"author":"akorin","excerpt":"\n记录通信原理的一些知识，重点记录数字通信系统\n\n","link":"/posts/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86","content":"\n记录通信原理的一些知识，重点记录数字通信系统\n\n<!-- more -->\n# 通信原理简记\n----\n\n## 0.预备知识\n### 0.1 分贝的定义\n\n$$\ndB=\\boldsymbol{10}\\log_{10}x\n$$\n分贝公式中前面的10容易忘记。此外需要牢记“3dB公式”：\n$$\n\\textcolor{red}{\\boldsymbol{3dB=10\\log_{10}2}}\n$$\n\n### 0.2 信噪比\n\n$$\n\\frac{信号功率}{噪声功率}=\\frac{P_s}{N}\n$$\n分贝表示：\n$$\n10\\log_{10}\\frac{信号功率}{噪声功率}=10\\log_{10}\\frac{P_s}{N}\n$$\n\n### 0.3 通信的基本概念\n\n- 通信：利用光电信号传输消息中所包含的信息\n- 通信的目的：在于传输含有信息的消息\n- 信息：消息的内涵（消息中所包含的有效内容）\n- 信息量：和消息内容的不确定有关\n- 消息：信息的物理表现形式。有连续信息（温度、语音）和离散信息（符号文字、计算机数据）\n- 信号：消息的传输载体。比如消息携载在电信号的某个参量（幅度、频率、相位）区别模拟信号和数字信号的关键在于携载信息的信号参量取值是连续的还是离散的\n- 调制信号：调制信号是指需要传输的原始信息信号。它通常是低频信号，也称为基带信号\n- 载波信号：载波是一个高频的正弦波信号，用于承载调制信号。载波的频率通常远高于调制信号的频率。调制时一般都是利用调制信号控制载波信号编程已调信号来传输\n- 已调信号：经调制后的高频载波，也可以叫做频带信号\n- 解调：从已调信号中提取出调制信号的过程，是调制的逆过程，也可以叫做检波\n\n### 0.4 通信系统的模型\n\n#### 0.4.1 一般通信系统\n\n![image.png](https://www.helloimg.com/i/2025/01/28/6797bbeec3f02.png)\n\n- 信源：将消息转化为电信号\n- 发送设备：产生适合在信道中传输的信号（调制）\n- 信道：传输信号的媒介\n- 接收设备：将收到的信号恢复成原始的信号（解调）\n- 信宿（受信者）：将信号转化为原始的消息（如扬声器）\n\n#### 0.4.2 模拟通信系统\n\n![image-2.png](https://www.helloimg.com/i/2025/01/28/6797bbeee4f5a.png)\n\n- 模拟信息源：将模拟消息转化为电信号（基带信号）\n- 调制器：将基带信号转化为带通信号（已调信号）\n- 信道：传输信号的媒介\n- 解调器：将带通信号解调为原始的基带信号\n- 信宿（受信者）：将原始电信号转化为模拟消息\n\n#### 0.4.3 数字通信系统\n\n![image-1.png](https://www.helloimg.com/i/2025/01/28/6797bbeed25fb.png)\n\n- 信源编码：模/数转换，将模拟信号转换为数字信号。将转化的数字信号进行压缩处理，减小冗余，提高信息传输的有效性。\n- 信源译码：信源编码的逆过程。\n- 信道编码：提高信息传输的可靠性，发现或纠正通信过程中产生的误码。信道编码通常需要在信息组中附加特定的码元，称为监督码，利用信息码和监督码的某种代数结构，检测或纠正错误。\n- 数字调制：产生适合在信道中传输的数字已调信号。\n\n### 0.5 通信系统分类\n\n- 按通信业务分类：电报通信系统、电话通信系统……\n- **按调制方式分类**：基带传输系统、带通传输系统（频带传输系统）\n- **按信号特征分类**：模拟通信系统、数字通信系统\n- **按传输媒介分类**：有线通信系统、无线通信系统\n- 按工作波段分类：长波通信、中波通信、短波通信\n- **按信号复用方式分类**：频分复用、时分复用\n\n### 0.6 通信方式\n\n- 单工通信：消息只能单方向传输的工作方式\n- 半双工通信：通信双方都能收发消息，但不能同时收发\n- 全双工通信：通信双方可同时进行收发消息的工作方式\n\n### 0.7 主要的性能指标\n\n- **有效性**：速度\n- **可靠性**：质量\n\n> 模拟系统的度量：\n>\n> - 有效性：有效传输频带宽度\n> - 可靠性：接收端最终输出信噪比\n\n> 数字系统的度量：\n>\n> - 有效性：传输速率和频带利用率\n> - 可靠性：差错率\n\n#### 0.7.1 数字通信系统传有效性\n\n- 码元传输速率R<sub>BN</sub>：定义为单位时间传输码元的数目，单位为波特(Baud)，简称为B（码元/秒，符号/秒）\n\n$$\nR_{BN} = \\frac{1}{T}\n$$\n其中T为码元的持续时间(s)\n\n- 信息传输速率R<sub>b</sub>：定义为单位时间传输的平均信息量或比特数，单位为比特/秒，记为b/s或bps。意味着无论码元是什么进制的最后的结果都要化成**二进制**\n- 不同进制码元速率和二进制码元速率的转换关系：\n\n$$\nR_B = R_{BN} \\times \\log_2N\n$$\n其中N为码元的进制数\n\n- 码元速率和信息速率的关系：\n\n$$\nR_b = R_{BN} \\times H\n$$\n其中H为信息熵（算术平均信息量，这里不过多赘述）\n\n- 频带利用率：定义为单位带宽(1Hz)内的传输速率\n\n$$\n\\eta=\\frac{R_{BN}}{B}\\space\\space\\space\\space\\space\\space\\space\\space(B/Hz)\n$$\n或\n$$\n\\eta=\\frac{R_b}{B}\n\\space\\space\\space\\space\\space\\space\\space\\space(b/s\\cdot{Hz})\n$$\n\n#### 0.7.2 数字通信系统可靠性\n\n- 误码率：\n\n$$\nP_e = \\frac{错误码元数}{传输总码元数}\n$$\n\n- 误信率：\n\n$$\nP_b = \\frac{错误比特数}{传输总比特数}\n$$\n在二进制中有:\n$$\nP_b = P_e\n$$\n\n### 0.8 噪声\n\n噪声是指在接收机中出现的任何不需要的电压或电流信号。噪声会引起模拟信号的失真，或数字信号的误码，**降低了通信系统的可靠性**\n\n#### 0.8.1 噪声的分类\n>\n> 按照噪声对信号的作用方式：\n>\n> - 加性噪声：叠加在信号上，大多数噪声都是加性噪声\n> - 乘性噪声：主要来自信道对信号的影响，当信道特性不理想时，需要通过对信道特性的补偿（均衡）去改善\n\n> 按照噪声的性质：\n>\n> - 脉冲噪声\n> - 单频噪声\n> - 起伏噪声：影响通信系统可靠性的主要因素\n\n#### 0.8.2 白噪声\n\n- 定义：功率谱密度为常数的噪声\n- 特性：统计特性服从高斯分布（一维高斯分布又称为正态分布），且均值为0。功率谱密度在很宽的范围内为常数，近似为白噪声。因此**起伏噪声**又称为**白噪声**\n\n## 1.通信信号分析\n\n### 1.1确知信号分析方法\n\n#### 1.1.1通信信号的分类方法\n\n- 模拟信号和数字信号：信号再时间和幅度上连续或离散的特点分类\n- 确知信号和随机信号：从信号是否可以用明确的表达式表示出来分类，确知信号又可以分为周期信号和非周期信号\n- 有用信号和噪声信号：从信号中是否携带有用信息来分类\n\n> 有意义的通信信号应具有随机性，但是其中也会存在确知信号\n\n#### 1.1.2 信号的基本分析方法\n\n- 时域分析法：直观体现信号波形\n- 频域分析法：利用傅里叶变换进行信号分析，揭示信号内在的频率特性\n\n#### 1.1.3 能量信号与功率信号\n\n- 能量信号：能量数值有界，功率为0\n- 功率信号：能量数值无界，功率数值有界\n\n> **各类信号之间的关系**\n>\n> **随机信号**与**确知的周期信号**是功率信号\n> \n> **确知的非周期信号**既可能是功率信号，也可能是能量信号\n>\n> 功率信号可以是**确知的周期、非周期或随机信号**，能量信号一定是**非周期信号**。在后面的分析中一般默认功率信号是确知周期信号\n\n#### 1.1.4 功率信号的频谱\n\n功率信号默认为确知周期信号，则分析功率信号时分析的是确知周期信号。周期信号频谱的三个特点：\n- 离散型\n- 谐波性\n- 收敛性：信号的能量主要集中在低频分两中（第一零点带宽）\n\n> **信号的频带宽度定义为：**\n> \n> 从零频率开始到需保留的最高频率分量之间的频率范围\n> ![QQ20250129-181523.png](https://www.helloimg.com/i/2025/01/29/6799febba7da3.png)\n> <center style=\"font-size:12px;color:#C0C0C0;text-decoration:underline\">第一零点带宽</center> \n\n#### 1.1.5 能量信号的频谱密度\n\n能量信号通常是非周期信号，非周期信号不能够直接用傅里叶级数表示，一般利用傅里叶变换得到频谱密度来表示。能量信号的频谱密度的特点：\n- 连续型\n- 单位是幅度/频率\n- 每个频率点上的信号幅度是无穷小的\n\n#### 1.1.6 帕斯瓦尔定理\n> **帕斯瓦尔定理**\n>\n> 对于能量信号，在时域中计算的信号总能量等于频域中计算的信号总能量\n> $$\n\\int ^\\infty _{-\\infty}f^2(t)dt=\\frac{1}{2\\pi}\\int ^\\infty _{-\\infty}|F(\\omega)|^2dw\n$$\n>\n> 对于周期性功率信号有\n> $$\nP=\\frac{1}{T}\\int ^\\frac{T}{2} _{-\\frac{T}{2}}f^2(t)dt=\\sum _{n=-\\infty} ^{n=\\infty}|F_n|^2\n> $$\n> 其中F<sub>n</sub>为周期信号的傅里叶频谱系数\n\n#### 1.1.7 希尔伯特变换\n> 希尔伯特变换在通信领域中有广泛的作用，它是信号分析与处理的重要工具\n$$\n\\^{f}(t)=H[f(t)]=\\int ^\\infty _{-\\infty} \\frac{f(\\tau)}{\\pi(t-\\tau)}d\\tau\n$$\n即\n$$\n\\^{f}(t)=H[f(t)]=f(t)\\ast\\frac{1}{\\pi t}\n$$\n在频域中为两个函数的傅里叶变换相乘。后者的傅里叶变换为$-jsgn(f)$，对正频率产生$-\\frac{\\pi}{2}$的相移，对负频率产生$\\frac{\\pi}{2}$的相移\n\n> 因此，希尔伯特变换又称为$\\frac{\\pi}{2}$移相器\n\n### 1.2 随机信号分析方法\n\n#### 1.2.1 随机过程\n\n随机过程可看成是一个由全部可能的实现构成的总体，每个实现都是一个确定的时间函数\n\n> **随机过程的定义**\n>\n> 随机过程是**样本函数的全体**，用$\\xi(t)$表示\n> \n> $\\xi(t)={x_1(t),x_2(t), \\ldots ,x_n(t), \\ldots }$\n> 其中$x_i(t)$是样本函数\n>\n> 或随机过程是依赖于时间参量t变化的**随机变量的全体**\n>\n> $\\xi(t)={X(t_1),X(t_2), \\ldots ,X(t_n), \\ldots }$\n> 其中$X(t_i)$是随机变量\n\n#### 1.2.2 随机过程的数字特征\n\n- 数学期望：随机过程的数学期望是时间t的函数$a^2(t)$可以看成随机过程的**直流功率**\n- 方差：方差$\\sigma^2(t)$可看作随机过程的**交流功率**\n  \n> **平均功率**\n> \n> $E[\\xi^2(t)]=a^2(t)+\\sigma^2(t)$\n\n- 自协方差函数B与自相关函数R：当$B(t_1,t_2)=0$时，表示$X(t_1)$与$X(t_2)$**线性不相关**\n\n> 自协方差函数$B(t_1,t_2)$\n>\n> $B(t_1,t_2)=E[\\xi(t_1)\\xi(t_2)]-a(t_1)a(t_2)$\n\n> 自相关函数$R(t_1,t_2)$\n>\n> $R(t_1,t_2)=E[\\xi(t_1)\\xi(t_2)]$\n\n#### 1.2.3 平稳随机过程\n\n> **平稳随机过程**\n>\n> 平稳随机过程指固定时间和位置的概率分布与所有时间和位置的概率分布相同的随机过程。随机过程的平稳性分为严格平稳和广义平稳\n>\n> - 严格平稳：任何n维分布函数或概率函数密度**与时间起点无关**。严格平稳又称为严平稳或**狭义平稳**\n>\n> - 广义平稳：均值与t无关，且为常数，同时自相关函数$R(\\tau)$只与时间间隔$\\tau$有关\n>\n> 平稳随机过程一定满足广义平稳，故**平稳随机过程**的**自相关函数$R(\\tau)$和时间t无关**，只与**时间间隔**$\\tau$**有关**\n\n> **各态历经性** \n>\n> 平稳随机过程的一个样本函数在整个时间轴上的时间平均值可以用来代替其统计平均值\n\n> **自相关函数的性质**\n>\n> - $R(0)=E{\\xi^2(t)}=P$\n> - 是对偶函数\n> - $R(0)\\ge |R(\\tau)|$\n> - $R(\\infty)=a^2$\n> - $R(0)-R(\\infty)=\\sigma^2$ \n> \n> 平均功率-直流功率=交流功率\n\n#### 1.2.4 高斯随机过程\n\n> **高斯过程**\n>\n> 高斯过程指任意维分布都服从高斯分布的随机过程\n\n> **高斯过程的性质**\n>\n> - 若高斯过程广义平稳，必将严格平稳\n> - 若高斯过程中的各随机变量之间是互不相关的，则必将统计独立\n\n#### 1.2.5 窄带高斯噪声\n\n> **窄带随机过程满足**\n>\n> 中心频率远小于带宽。窄带过程是一个包络和相位缓慢变化的正弦波\n\n> **白噪声的性质**\n>\n> - 白噪声的功率谱密度：$P_n(\\omega)=\\frac{n_0}{2}$\n> - 白噪声的自相关函数：$R(\\tau)=F^{-1}{P_n(\\omega)}=\\frac{n_0}{2}\\delta(\\tau)$\n\n## 2.模拟调制系统\n### 2.1 引言（模拟+数字）\n#### 2.1.1 调制的主要作用\n\n- 形成带通型信号频谱，使发送到呃频带信号的频谱匹配与信道的带同特性\n- 实现信道的多路复用\n\n::: tip 频分复用(FDM)\n\n将多个基带信号分别搬到不同的载频处，以实现信道的多路复用技术\n\n:::\n\n- 通过采用不同的调制方式可以兼顾通信的有效性和可靠性\n\n#### 2.1.2 调制方式\n\n- 连续波调制（用于雷达）、脉冲波调制\n- 模拟调制、数字调制（以调制信号的种类划分）\n\n### 2.2 幅度调制（模拟）\n\n> **幅度调制（线性调制）**\n>\n> 由调制信号去控制高频载波的**幅度**，使之随调制信号作线性变化的一种调制方式\n\n> **幅度调制的四种类型**\n>\n> - 调幅(AM)\n> - 双边带(DSB)\n> - 单边带(SSB)\n> - 残余边带(VSB)\n\n> **特点**\n>\n> - 已调信号的幅度随基带信号呈正比例变化\n> - 已调信号的频谱是基带信号频谱的**频谱搬移**\n\n### 2.3 AM调制\n\n设**调制信号**表达式为$m(t)=A_m\\cos\\omega_mt$\n\n**载波信号**表达式为$c(t)=A\\cos(\\omega_ct+\\varphi_0)$\n\n为了分析方便一般将$\\varphi_0$设为0，则AM信号的表达式：\n$$\ns_{AM}(t)=[A_0+m(t)]\\cos\\omega_ct\n$$\n\nAM调制器模型：\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/AMtiaozhi.png)\n\nAM调制器波形图：\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/AM波形图.png)\n\nAM调制器信号频谱原理：\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/amtiaozhipinpu.png)\n\n\n#### 2.3.1 AM信号功率\n\n设$\\overline{m(t)}=0$可推出\n\n$P_{AM}=\\frac{A_0^2}{2}+\\frac{\\overline{m^2(t)}}{2}=P_c+P_s$\n\n其中$P_c$为不携带信息的功率，$P_s$为携带信息的功率\n$$\n\\eta_{AM}=\\frac{P_s}{P_{AM}}=\\frac{\\overline{m^2(t)}/2}{[A_0^2+\\overline{m^2(t)}/2]}\n$$\n\n::: warning 注意\n\n当$|m(t)|_{max}=A_0$时，称为AM的临界调制或100%调制，此时$\\overline{m^2(t)}=\\frac{A_0^2}{2}$，$\\eta_{AM}=\\frac{1}{3}$\n:::\n\n#### 2.3.2 AM的包络检波\n\nAM的包络检波器将$\\cos\\omega_ct$滤去，得到$s_d(t)=A_0+m(t)$，再将直流信号$A_0$滤去后即可得到原始调制信号$m(t)$\n\n检波中无需额外提供或提取载波，电路简单\n \n包络检波法是中、小型幅度调制系统的首选解调方法\n\n\n### 2.4 DSB调制\n\n> DSB调制模型\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/dsbtiaozhi.png)\n\n**载波信号**表达式为$S_{DSB}=m(t)\\cos\\omega_ct$\n\n其中$\\overline{m(t)}=0$\n\n> DSB调制波形\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/DSB调制波形.png)\n\n> DSB调制原理\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/DSByuanli.png)\n\nDSB信号节省了载波功率，其调制效率可达100%。DSB信号两个边带中的**任意一个**都包含了调制信号的所有频谱成分\n\n::: warning 注意\n\n对比AM调制的波形，少了两个冲激的波形\n\n:::\n\n> 综上可知DSB的带宽为\n\n$$\nB_{DSB}=2f_H\n$$\n\n#### 2.4.1 DSB解调\n\n使用相干解调器（同步检测）\n\n::: tip 相干解调\n\n用同频同相的载波信号乘以调制信号解调出基带信号的方法\n\n:::\n\n> 相干解调器模型\n> ![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/DSB相干解调其模型.png)\n\n其中$s_m(t)$是调制信号（已调信号），且\n$$\n\ns_m(t)=m(t)\\cos\\omega_ct \\\\\ns_p(t)=m(t)\\cos\\omega_ct\\cos\\omega_ct\n\n$$\n\n经过低通滤波器LPF后可得\n$$\n\ns_d(t)=\\frac{1}{2}m(t)\n\n$$\n\n### 2.5 SSB调制\n\nSSB调制可由两种方式得来：\n- 滤波法：从DSB信号中滤波得到\n- 移相法\n\n#### 2.5.1 滤波法SSB信号\n\n> 滤波法SSB调制模型\n> ![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/滤波法SSB调制模型.png)\n\n而此时SSB有两种调制方式\n- 上边带调制USB：滤除下边带，保留上边带\n- 下边带调制LSB：滤除上边带，保留下边带\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/什么是SSB.png)\n\n此时可得通式：\n$$\ns_{SSB}(t)=\\frac{1}{2}A_m\\cos\\omega_mt\\cos\\omega_ct\\mp\\frac{1}{2}\\sin\\omega_mt\\sin\\omega_ct\n$$\n其中减号对应USB，加号对应LSB\n\n当利用滤波法调制SSB波形时，若$H(\\omega)$为**理想高通**特性，则得到上边带信号（USB）\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/滤波法SSB调制波形.png)\n\n::: warning 注意\n\nSSB的频谱是滤去其中一个边带后的结果\n\n:::\n\n$$\nS_{SSB}(\\omega)=S_{DSB}(\\omega)\\cdot{H(\\omega)}\n$$\n\n\n\n> 则此时SSB信号的带宽为\n\n$$\nB_{SSB}=f_H\n$$\n\n#### 2.5.2 相移法SSB信号\n\n在滤波法实现SSB的方法中，理想边带滤波器$H(\\omega)$很难实现，因此使用相移法是一个实际应用SSB调制的方法\n\n> 移相法SSB模型\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/移相法SSB调制器.png)\n\n其中方框$-\\frac{\\pi}{2}$为希尔伯特移相变换\n\n> 最后得到SSB的表达式\n$$\ns_{SSB}(t)=\\frac{1}{2}m(t)\\cos\\omega_ct\\mp\\frac{1}{2}\\^m(t)\\sin\\omega_ct\n$$\n即为\n$$\ns_{SSB}(t)=\\frac{1}{2}A_m\\cos\\omega_mt\\cos\\omega_ct\\mp\\frac{1}{2}\\sin\\omega_mt\\sin\\omega_ct\n$$\n\n::: warning 注意\n\n$m(t)=A_m\\cos\\omega_ct\\\\\\^m(t)=A_m\\sin\\omega_ct`$\n\n:::\n\n与前面滤波法SSB得到的结果一致\n\n#### 2.5.3 SSB信号的解调\n\n解调器结构同DSB一致\n> 相干解调器\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/DSB相干解调其模型.png)\n\n经过低通滤波器LPF后\n$$\ns_d(t)=\\frac{1}{4}m(t)\n$$\n\n### 2.6 VSB调制\n\nVSB调制是介于SSB与DSB调制之间的一种折衷方案，使用滤波法进行调制\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/VSB模型.png)\n\n> VSB调制模型\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/VSB调制器.png)\n\n其中残留边带滤波器$H(\\omega)$表示VSB滤波器的传输特性\n\n#### 2.6.1 VSB的解调\n\nVSB信号必须采用相干解调，为了分析方便，将载波幅度设为2\n\n> 相干解调模型\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/VSB相干解调.png)\n\n则最后经过LPF可得\n$$\nS_d(\\omega)=\\frac{1}{2}M(\\omega)[H(\\omega+\\omega_c)+H(\\omega-\\omega_c)]\n$$\n\n::: danger 为了保证无失真恢复调制信号，必须满足\n\n$$\nH(\\omega+\\omega_c)+H(\\omega-\\omega_c)=C,|\\omega|\\le \\omega_H\n$$\n其中C为常数\n:::\n\n当残留边带滤波器传输特性$H(\\omega)$关于$\\omega_c$**互补对称（奇对称），相干解调时才能无失真地恢复调制信号**\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/VSB相干解调原理.png)\n\n此时VSB的带宽\n$$\nB_{VSB}\\approx B_{SSB}\\Leftrightarrow B_{VSB}=1.25B_{SSB}\n$$\n\nDSB、SSB、VSB之间带宽的比较\n$$\nB_{SSB}<B_{VSB}<B_{DSB}\n$$\n\n### 2.7 角度调制系统\n\n正弦载波的三个参量（幅度、频率、相位）都可以用来携带调制信号\n\n- 幅度调制：调制信号控制载波的幅度\n- 频率调制FM（调频）：用调制信号去控制载波频率；已调信号的瞬时角频偏正比于调制信号\n- 相位调制PM（调相）：用调制信号去控制载波相位；已调信号的瞬时相位偏移正比于调制信号\n\n角度调制信号的一般表达式为\n$$\ns_m(t)=A\\cos[\\omega_ct+\\varphi(t)]\n$$\n- A为载波的振幅，为常数\n- $[\\omega_ct+\\varphi(t)]$为瞬时相位\n- $\\varphi(t)$为相对与载波相位$\\omega_ct$的瞬时相位偏移\n- $d[\\omega_ct+\\varphi(t)]/dt$是瞬时角频率\n- $d\\varphi(t)/dt$为相对于载频$\\omega_c$的瞬时角频偏\n\nFM和PM统称为**角度调制**\nFM和PM的已调信号的频谱不仅有频谱搬移，且频谱的结构也会发送变化\n\n> 因此角度调制又称为非线性调制\n\n#### 2.7.1 概念\n\n设载波信号为：\n$$\ns(t)=A\\cos(\\omega_ct+\\varphi_0)\n$$\n调制信号为$m(t)$\n\n- FM信号：$s_{FM}(t)=A\\cos[\\omega_ct+K_f\\int^t_0m(\\tau)d\\tau]$，此时$\\varphi_0=[K_f\\int^t_0m(\\tau)d\\tau]$\n- PM信号：$s_{PM}(t)=A\\cos[\\omega_ct+K_pm(t)]$，此时$\\varphi_0=[K_pm(t)]$\n\n其中$K_f$和$K_p$分别是调频指数和调相指数\n\n对比两者可得知：将基带信号先积分再调相，等同于调频；将基带信号先微分再调频，等同于调相\n\n::: warning 关于“将基带信号先微分再调频，等同于调相”的理解\n\n如果我们将基带信号 m(t) 先微分，再进行频率调制，那么： \n\n$$\n \\frac{d}{dt} m(t) = m'(t) \n$$ \n\n此时，频率调制的已调信号变为： \n\n$$ \ns_{FM}(t) = A \\cos \\left( \\omega_c t + K_f \\int_0^t m'(\\tau) d\\tau \\right) \n$$ \n\n由于积分和微分是互逆运算，因此： \n\n$$ \n\\int_0^t m'(\\tau) d\\tau = m(t) \n$$ \n\n所以，频率调制的已调信号可以表示为： \n\n$$ \ns_{FM}(t) = A \\cos \\left( \\omega_c t + K_f m(t) \\right) \n$$ \n\n这与相位调制的已调信号形式相同，只是调制指数不同。因此，将基带信号先微分再进行频率调制，等同于相位调制。只不过此时$K_f$相当于调相灵敏度\n\n:::\n\n#### 2.7.2 单音调制时的FM与PM波形\n\n:::tip 单音\n\n单音指调制信号为单一频率的正弦波，即\n\n$$\n\nm(t)=A_m\\cos\\omega_mt=Am\\cos2\\pi f_mt\n\n$$\n\n:::\n\n- 调频信号：$s_{FM}(t)=A\\cos(\\omega_ct+m_f\\sin\\omega_mt)$\n- 调频信号：$s_{PM}(t)=A\\cos(\\omega_ct+m_p\\cos\\omega_mt)$\n\n其中\n\n- 调频指数：$m_f=\\frac{K_fA_m}{\\omega_c}$（$\\frac{1}{\\omega_c}$是从积分来的），它也是最大的相位偏移量\n- 调相指数：$m_p=K_pA_m$，它也是最大的相位偏移量\n\n其中$K_fA_m$是最大的角频率偏移量，表示为$\\triangle\\omega$，则$m_f$与$\\triangle f$的关系为\n$$\n\nm_f=\\frac{K_fA_m}{\\omega_m}=\\frac{\\triangle\\omega}{\\omega_m}=\\frac{\\triangle f}{f_m}\n\n$$\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/PMFM图像.png)\n\n由图可知，FM与PM的表现形式相同，都是已调信号频率的稀疏变化，区别在于PM是相位偏移随调制信号m(t)线性变化，FM是频率偏移随m(t)线性变化。若预先不知道调制信号m(t)的具体形式，则无法判断已调信号是PM信号还是FM信号\n\n实际运用上FM较多，主要讨论FM信号\n\n> FM信号的带宽（卡森公式/调频信号带宽公式）：\n$$\n\nB_{FM}=2(m_f+1)f_m=2(\\triangle f+f_m)\n\\\\f_m=\\frac{\\omega_m}{2\\pi}\n\n$$\n\nFM的频谱理论值无穷大，但可根据调频指数$m_f$分为宽带调频和窄带调频\n\n- $m_f\\gg1$时，为宽带调频，此时\n\n$$\n\nB_{FM}\\approx2m_ff_m=2m_f\\frac{\\omega_m}{2\\pi}=2\\frac{\\triangle\\omega}{2\\pi}=2\\triangle f=2\\frac{K_fA_m}{2\\pi}\n\n$$\n\n只与信号强度有关，与调制信号频率无关\n\n- $m_f\\ll 1$时，为窄带调频，此时\n\n$$\n\nB_{FM}\\approx2f_m=2\\frac{\\omega_m}{2\\pi}\n\n$$\n\n与AM信号带宽相同\n\n> FM与PM之间的关系\n> ![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/FNPM关系.png)\n\n#### 2.7.3 各种模拟系统输出信噪比的比较\n\n在信道条件相同下，若解调器输入端的信号功率相同，设$\\overline{m^2}(t)=\\frac{A^2}{2}$\n$$\n\n(\\frac{S_0}{N_0})_{AM}=\\frac{1}{3}\\frac{S_i}{N_0B_b} \\\\\n(\\frac{S_0}{N_0})_{DSB}=\\frac{S_i}{N_0B_b} \\\\\n(\\frac{S_0}{N_0})_{SSB}=\\frac{S_i}{N_0B_b} \\\\\n(\\frac{S_0}{N_0})_{FM}=\\frac{3}{2}m^2_f\\frac{S_i}{N_0B_b} \\\\\n\n\n$$\n\n#### 2.8 信道的频分复用\n\n:::tip 信道复用\n\n将物理信道按照不同的属性参量（如时间、频率等）划分成若干个子频带（或称子信道），供多路信号同时使用\n\n:::\n\n- 频分复用(FDM: Frequency Division Multiplexing)\n- 时分复用(TDM: Time Division Multiplexing)\n- 码分复用(CDM: Code Division Multiplexing)\n- 正交频分复用(OFDM: Orthogonal frequency Division Multiplexing)\n\n信道复用时为了提高信道的利用率\n\n\n::: tip 频分复用(FDM: Frequency Division Multiplexing)\n\n将多个基带信号分别搬到不同的载频处，以实现信道的多路复用技术\n\n:::\n\n> **特点：** FDM是模拟通信中的一种主要服用方式，信道复用率高，复用路数多，分接方便\n\n::: tip 时分复用 (TDM: Time Division Multiplexing)\n\n时分复用是一种将多个信号在时间上进行分割，并在同一信道上依次传输的技术。每个信号在不同的时间片段内占用信道，从而实现多路信号的传输\n\n:::\n\n\n#### 2.8.1 OFDM与FDM的频谱效率比较\n\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/FDMOFDM的比较.png)\n\n#### 2.9 各类模拟调制系统性能比较\n\n| 调制方式 | 传输带宽      | 调制制度增益               | 主要应用                 |\n| -------- | ------------- | -------------------------- | ------------------------ |\n| AM       | $2f_m$        | 小于1，近似为$\\frac{2}{3}$ | 中波和短波调幅广播       |\n| DSB      | $2f_m$        | 2                          | 彩色电视系统（色差信号） |\n| SSB      | $f_m$         | 1                          | 短波无线电广播载波通信   |\n| VSB      | 略大于$f_m$   | 约等于1                    | 电视广播（图像信号）     |\n| FM       | $2(m_f+1)f_m$ | $3m^2_f(m_f+1)$            | 小型电台、电视广播、卫星通话 |\n\n- 有效性：（优）→（劣）SSB、VSB、AM(DSB)、FM\n- 可靠性：（优）→（劣）WBFM、SSB(DSB、VSB)、AM\n\n#### 2.10 载波同步\n\n:::tip 载波同步\n\n载波同步是通信系统中一个关键的过程，它确保接收端能够正确地恢复出发送端的载波信号。载波同步的主要目的是在接收端生成一个与发送端载波信号相同频率和相位的本地载波信号，以便进行相干解调。\n\n在**相干解调器**中，需要用载波同步器来提取本地相干载波，用于已调信号的解调，相干载波应与调制载波同频同相。\n\n:::\n\n载波同步分为直接发和插入导频法两类方法\n\n- 直接法：直接从接收信号中提取载波信号\n- 插入导频法：在已调信号中加入额外的载频分量（导频分量）\n\n#### 2.10.1 载波同步器性能指标\n\n- 同步建立时间：从开始接收到信号（或从系统失步状态）至提取出稳定的载频所需要的时间\n  > 同步建立时间**越短越好**\n\n- 同步保持时间：从开始失去输入信号到市区载频同步的时间\n  > 同步保持时间**越长越好**。当同步保持时间唱，则在输入信号短暂丢失时，保持连续提供本地载频，不需要重新建立同步\n\n- 相位误差：由电路常数引起，或由噪声引起\n  > 相位误差降低了输出信号功率，对噪声功率没有影响，结果是会引起输出信噪比的下降\n\n## 3.数字信号的基带传输\n### 3.1 数字基带信号波形与频谱\n#### 3.1.1 基本的数字基带信号波形\n\n> 单极性信号波形：\n- +A电平 <--> 码元\"1\"\n- 0电平  <--> 码元\"0\"\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/单极性波形.png)\n> 双极性信号波形：\n- +A电平 <--> 码元\"1\"\n- -A电平 <--> 码元\"0\"\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/双极性波形.png)\n> 差分信号极性波形：\n- 相邻码元电平改变 <--> 码元\"1\"\n- 相邻码元电平不变  <--> 码元\"0\"\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/差分波形.png)\n> 多电平信号波形：\n- 一个M进制码元的信号波形，含有M种信号电平，下图为四电平波形\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/四电平波形.png)\n\n> 由上图观察可得到：归零和不归零波形的占空比不同\n\n\n$占空比=\\frac{脉冲宽度}{码元宽度}=\\frac{\\tau}{T_B} \\quad \\tau$：主瓣带宽（第一零点带宽）\n\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/20250222160002091.png、)\n\n- $\\tau=T_B$：不归零码\n- $\\tau=\\frac{T_B}{2}$：半占空归零码\n\n\n:::tip 归零码\n\n归零码（Return-to-Zero, RZ）是一种数字信号编码方式。在归零码中，每个码元周期内信号都会返回到零电平，即无论码元是“1”还是“0”，信号在每个码元周期的中间都会回到零电平。如上图中b、d\n\n:::\n \n#### 3.1.2 基带信号的频谱\n\n基带信号是**随机**脉冲序列，没有确定的频谱函数，只能用平均功率谱来描述它的频谱特性\n\n基带信号的频谱包含：基带信号的**主瓣宽度**、**直流分量**、**位定时**\n\n### 3.2 基带传输的常用码型\n\n> 为了适应信道的传输，传输码型必须具备以下**基本特性**：\n> - 无直流、很少的低频分量\n> - 含有码元定时信息\n> - 主瓣宽度窄\n> - 适用于各种信源的统计特性\n> - 具有一定的纠错能力\n> - 有利于减少误码扩散\n\n#### 3.2.1 二元码\n\n二元码即二电平码\n\n##### 3.2.1.1 双相(BiPhase)码\n\n又称为**曼彻斯特**(Manchester)码，是用具有不同相位的二进制编码取表示消息\n\n| 消息码   | 1   | 0   |\n| -------- | --- | --- |\n| 信号波形 | ![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/20250222160825997.png) |![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/20250222160847289.png)|\n\n> 特点：\n> - 码元中间存在电平的跳变，能够提供足够的定时分量\n> - 每个码元正负电平各占一半没有直流分量\n> - 编码过程相对简单，可以用单极性不归零码金额系统定时信号的模2加产生\n> - 主要用于局域网\n\n##### 3.2.1.2 传号反转码(CMI码)\n\n| 消息码           | 1                | 0   |\n| ---------------- | ---------------- | --- |\n| 信号传输表示方法 | 交替用\"11\"和\"00\" | \"01\" |\n\n> 特点：\n> - 无直流分量\n> - 有较多的电平跃变，含有丰富的定时信息\n> - 具有一定的检错能力，不可能出现\"10\"的组合，也不会出现连续的\"11\"或者\"00\"\n> - 被CCITT推荐为PCM四次群的接口码型\n\n##### 3.2.1.3 米勒码(Miller码)\n\n| 消息码           | 1                | 0    |\n| ---------------- | ---------------- | ---- |\n| 信号传输表示方法 | 交替用\"10\"和\"01\" | 交替用\"11\"和\"00\" |\n\n![](https://pub-3f9780acd0d54f9dabe63c0a1ab77225.r2.dev/20250222161823266.png)\n\n##### 3.2.1.4 nBmB码\n\nn位二进制-->m位二进制，通常m=n+1\n\n新的码组有 $2^m$ 种可能的组合，从中选择一部分有利的码组作为**许用码组**，其余为**禁用码组**，这样就有一定的检错能力\n\n主要用于光线数字传输系统中\n\n#### 3.2.2 三元码\n\n三元码的幅度取值有：$+1、0、-1$\n\n##### 3.2.2.1 传号交替反转码(AMI)码\n\n| 消息码           | 1                | 0                |\n| ---------------- | ---------------- | ---------------- |\n| 信号传输表示方法 | 交替用\"+1\"和\"-1\" | 0 |\n\n> 特点：\n> - 无直流分量，只有很小的低频成分\n> - 编译码简单\n> - 主要缺点是可能出现长连0串，可能导致定时信号提取困难\n\n##### 3.2.2.2 三阶高密度双极性码($HDB_3$码)\n\n$HDB_3$ 就是AMI码的改进码\n\n> 编码规则：\n> - 在AMI码的基础上，当连0串少于4个时，此时的AMI码就是 $HDB_3$ 码\n> - 当出现4个或4个以上连0串时，则将每4连0串的第4个0变换成与其前一非0符号**同极性**的符号，这个符号就是**破坏符号V**，+V -V交替出现\n> - 当相邻4连0段之间有奇数个非0符号时，后一个4连0用取代节\"000V\"代替;当有偶数个非0符号时，后一个4连0用取代节\"B00V\"代替；B符号的机型与前一非零符号**相反**，B符号是用来确保破坏符号的规则能够满足\n\n![](https://pic.akorin.icu/20250225160900679.png)\n\n> 特点：\n> - $HDB_3$ 编码较复杂，译码较简单\n> - 每一个破坏符号V总是与前一非0符号**同极性**\n> 从接受符号序列中很容易找到破坏点V，也易判断V及前面的3个符号必是连0符号，从而恢复4个连0码\n\n##### 3.2.2.3 4B/3T\n\n上述的两种码型都是1B/1T，即将1个二进制符号用三进制符号代替，4B/3T时1B/1T的改进型，可提高频带利用率，适用于较高速率的数据传输系统\n\n\n### 3.3 无码间干扰的基带传输\n\n#### 3.3.1 基带传输系统的基本结构\n![](https://pic.akorin.icu/20250225162142154.png)\n\n- $d(t)$：输入基带信号\n- $m(t)$：无干扰时的基带传输信号\n- $r'(t)$：乘性干扰下的输出信号\n- $r(t)$：乘性干扰和加性噪声影响下的输出信号\n- $d'(t)$：再生的输出信号\n\n\n:::tip 码间串扰\n\n由于干扰的影响，造成码元间的互相重叠，从而影响正确判决\n\n:::\n\n\n> 无噪声系统与有噪声系统\n>![](https://pic.akorin.icu/20250225162750657.png)\n\n> 无码间干扰的时域条件\n\n$$\nh[(k-n)T_B]=\n\\begin{cases}\n    A\\quad n=k\\\\\n    0\\quad n\\neq k\n\\end{cases}\n$$\n\n> 无码间串扰的频域条件\n\n$$\n\n\\sum\\limits_iH(f+\\frac{i}{T_B})=T_B \\quad or \\quad 常数 \\quad |f| \\le \\frac{1}{2T_B}\n\n$$\n\n:::warning\n\n频域条件又称为**奈奎斯特第一准则**\n\n:::\n\n一个带宽为 $f_N$ 的理想低通系统，它的最高无码间干扰速率为 $2f_N$，也称为 **奈奎斯特速率**，反过来说：\n\n若要实现速率为 $R_B$ 的无码间干扰传输，需要的理想低通系统最小带宽为 $\\frac{R_B}{2}$，称为**奈奎斯特带宽**，此时其频带利用率（极限频带利用率）为 $\\eta=2 \\quad Bd/Hz$\n\n\n#### 3.3.2 眼图\n\n对于一个实际的传输系统，码间干扰不可能完全避免\n\n计算误码率和性能非常困难，甚至无法实现\n\n> **眼图**：\n> 用示波器观察数字基带系统接收信号，所得到的图像，形式很像人的眼睛\n> 通过眼图可以观察处码间干扰和噪声的影响，估计系统性能的优劣程度\n> ![](https://pic.akorin.icu/20250225165351994.png)\n\n> **眼图模型**：\n> ![](https://pic.akorin.icu/20250225165438521.png)\n\n> **奈奎斯特第二定律**：\n\n> 也称为奈奎斯特第二条件，是在通信系统中用于减少或消除码间干扰（ISI）的一个重要准则。为了避免码间干扰，传输系统的频率响应 ( H(f) ) 应该满足以下条件：\n\n$$ \n\\sum_{i=-\\infty}^{\\infty} H(f - i/T_B) = T_B \n$$\n\n其中，$T_B$ 是码元周期，$H(f)$ 是系统的频率响应。\n\n\n### 3.4 位同步\n\n> **位同步目的**：\n> 确定接受码元起始时刻，以保证正确检测和判决所接受的码元\n\n> **码元同步方法**：\n> - 外同步法：利用辅助信息同步的方法需要在传输信号中另外加入包含码元定时信息的导频信号\n> - 自同步法：不需要辅助同步信息，直接从接收信号序列中提取出码元定时信息\n\n### 3.5 均衡技术\n\n> 均衡器的概念：\n> 在数字基带系统输出端加入一种可调（或不可调）滤波器，减小码间干扰的影响\n\n> 均衡器的分类：\n> - 时域均衡器(TDE)\n> - 频域均衡器(FDE)\n\n\n## 4.模拟信号数字化 :star::star::star::star::star:\n\n主要针对PCM电话通信系统\n\n### 4.1 脉冲编码调制PCM\n#### 4.1.1 PCM系统模型\n\n**PCM(Pulse Code modulation)** 即脉冲编码调制，是一种将时间连续、取值连续的模拟信号变换成时间离散、抽样值离散的数字信号的过程\n\n![](https://pic.akorin.icu/20250225172218086.png)\n\n如上图PCM系统包括**编码器**和**译码器**两部分\n\n- 抽样：将模拟信号由时间上连续的信号编程时间上离散的信号，抽样必须遵循抽样定理\n- 量化：将抽样得到的幅度瞬时值离散化的过程，将连续的瞬时抽样值近似为离散的电平值\n- 编码：用二进制码组表示每一个量化电平。若编码后二进制码组的位数用N表示，则可以表示的量化电平数为 $2^N$ 个\n\n#### 4.1.2 PCM术语说明\n\n- 对脉冲**幅度**进行调制：PAM(Pulse-Amplitude Modulation)\n- 对脉冲**宽度**进行调制：PDM(Pulse-Duration Modulation)\n- 对脉冲**相位**进行调制：PPM(Pulse-Postion Modulation)\n\n上述都是周期性的矩形脉冲序列\n\n#### 4.1.3 PCM系统的奈奎斯特带宽\n\n设模拟信号抽样频率为 $f_s$ ，每个样值编码位数为N，则单路的PCM信号的码元速率为 $R_B=Nf_s$ \n\nk路复用则PCM系统的码元速率为 $kNf_s$\n\n在无码间串扰下，[奈奎斯特带宽](https://akorin.icu/posts/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86#_3-3-1-%E5%9F%BA%E5%B8%A6%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84)指**理想低通系统**所需的最小带宽，为 $\\frac{kNf_s}{2}$\n\n当采用**升余弦系统**传输时，所需带宽为 $kNf_s$\n\n### 4.2 模拟信号的抽样\n#### 4.2.1 抽样定理\n\n> 抽样信号：周期性的冲激序列 $\\delta_T(t)$\n\n设模拟信号频率范围为 $f_L~f_H$ ，带宽为 $B=f_H-f_L$\n\n- 低通信号： $B>f_L$\n- 带通信号： $B\\le f_L$\n\n#### 4.2.2低通信号抽样定理\n\n对于频带限制在 $0~f_H$ 的低通信号 $m(t)$ ，若以频率 $f_s\\ge 2f_H$ **抽取瞬时样值**，则可无失真恢复原模拟信号\n\n![](https://pic.akorin.icu/20250228095014020.png)\n\n#### 4.2.3 模拟基带信号的恢复\n\n使用截止频率为 $f_H$ 的低通滤波器\n\n滤波器的频域系统函数为：\n$$\nH(f)=\n\\begin{cases} 1, & |f|\\le f_H  \\\\ 0, & |f|>f_H \\end{cases}\n$$\n\n其时域的表达式为\n\n$$\nh(t)=F^{-1}[H(\\omega)]=\\frac{\\omega_H}{\\pi}Sa(\\omega_Ht)\n$$\n\n输出信号\n\n$$\nm_0(t)=F^{-1}[M_s(f)\\cdot H(f)]=m_s(t)\\ast h(t)=\n$$\n\n$$\n\\frac{\\omega_H}{\\pi}\\sum\\limits_{n=-\\infty}^\\infty m(nT_s)\\delta(t-nT_s)\\ast Sa(\\omega_Ht)=\\frac{\\omega_H}{\\pi}\\sum\\limits_{n=-\\infty}^\\infty m(nT_s) Sa[\\omega_H(t-nT_s)]\n$$\n\n上述叠加过程称为 **内插**\n\n#### 4.2.4 带通信号的抽样定理\n\n频谱范围为 $f_L~f_H$ ，信号带宽 $B\\le f_L$则\n\n$$\nf_s=\\frac{2f_H}{n}=2\\frac{(n+k)B}{n}=2B(1+\\frac{k}{n}) \\quad 0\\le k<1\n$$\n\n其中 $n$ 是 $\\frac{f_H}{B}$ 取整部分； $k$ 是 $\\frac{f_H}{B}$ 的小数部分，当 $n\\gg1$ 时，$f_s=2B$\n\n![](https://pic.akorin.icu/20250228102640421.png)\n\n### 4.3 实际抽样\n\n- 自然抽样：抽样信号为周期性矩形脉冲序列![](https://pic.akorin.icu/20250228103859362.png)\n- 平顶抽样：![](https://pic.akorin.icu/20250228103942415.png)\n\n### 4.3 抽样信号的量化\n\n- 抽样后信号的幅值在其值域内依然是**连续信号**\n- 对连续的抽样值进行离散处理称为**量化**\n\n#### 4.3.1 均匀量化\n\n将模拟信号的取值范围分为若干量化区间，也成为**量化间隔**\n\n若各量化区间相等则称为**均匀量化**，否则称为非均匀量化\n\n- 设模拟信号的值域： -a~a\n- 量化区间数： M\n- 设二进制编码位数： N，应保证 $2^N\\ge M$ ，可取 $M=2^N$\n- 均匀量化： $\\triangle v=\\frac{2a}{M}$\n- 量化值： $q_i$ 一般取量化区间的中间值，且当 $m_{i-1}\\le m_k<m_i$ 时，$m_q=q_i$\n\n$$\nq_i=\\frac{m_i+m_{i-1}}{2}=-a+i\\triangle v-\\frac{\\triangle v}{2}\n$$\n\n- 量化噪声的平均功率： $N_q=\\frac{(\\triangle v)^2}{12}$\n- 信号的平均功率： $S_0=\\frac{M^2}{12}(\\triangle v)^2$\n- 量化信噪比： $\\frac{S_0}{N_q}=M^2=2^{2N}$\n\n> 主要结论：\n> - 量化信噪比与量化等级数或编码位数有关\n> 量化噪声功率只与量化间隔有关\n> 对于小输入信号，瞬时量化信噪比较小，对于大输入信号，瞬时量化信噪比较大\n> 均匀量化不适合处理电话语音信号，因为电话语音信号小信号占多数，信噪比低\n\n#### 4.3.2 非均匀量化 :star::star::star::star::star:\n\n非均匀量化采用可变的量化间隔，让小信号量化间隔小一些，大信号量化间隔大一些，在编码位数和量化等级不变的情况下，可以**提高小信号的信噪比**\n\n非均匀量化可以通过对输入信号进行非线性处理后再均匀量化实现。\n\n:::tip 非线性处理\n对小信号放大倍数大，对打信号放大倍数小。在发送端的非线性处理成为压缩\n\n在接收端消除信号失真称为扩张，扩张是压缩的逆过程\n:::\n\n考虑到双极性信号的输入，他所特性包含第一、三象限两部分，且相互奇对称\n\n> 理想压缩特性\n\n**“理想”**量化间隔正比于输入信号，将压缩器和输入和输出信号归一化，x和y的取值范围均在0~1之间。y轴的量化间隔 $\\triangle y=\\frac{1}{M}$ （y轴平均）\n\n量化区间数M通常比较大，因此每个量化区间内的曲线可以近似看作直线段\n\n$$\n\\frac{\\triangle y}{\\triangle x}=\\frac{dy}{dx}\\Rightarrow\\triangle x=\\frac{dx}{dy}\\triangle y= \\frac{1}{M}\\frac{dx}{dy}\n$$\n![](https://pic.akorin.icu/20250228144053221.png)\n解该线性微分方程可得： $\\ln x=ky-k$，\n\n边界条件： $x=1$ 时， $y=1$，则 $y=1+\\frac{1}{k}\\ln x$ 或称为**对数压缩特性**\n\n----\n> A律标准 \n\n理想压缩特性是物理不可实现的，因为当 $x=0$ 时， $y=-\\infty$\n\n在理想压缩特性曲线上修正后可得A律标准：\n\n$$\ny=\\begin{cases} \\frac{1+\\ln Ax}{1+\\ln A}, &  \\frac{1}{A}<x\\le 1\\\\ \\frac{Ax}{1+\\ln A}, & 0\\le x\\le \\frac{1}{A} \\end{cases}\n$$\n\n常数A决定了压缩程度，当 $A=1$ 时， $y=x$ ，未压缩，相当于均匀量化。当 $A>1$ ，进行压缩\n\n![](https://pic.akorin.icu/20250228144122798.png)\n\n----\n> 13折线压缩特性\n\nA律标准的特性很难用模拟电路的方法去实现，利用数字电路较容易精确实现A律标准。具体做法是将A律标准分段线性化，当总的量化等级足够多的情况下，可以得到逼近A律标准的近似曲线\n\n将x轴的0~1对分为8段，y轴0~1等分为8段，将相应的点相连，构成8根折线\n\n“13折线”是A=87.6的A律特性的近似\n\n![](https://pic.akorin.icu/20250228145512173.png)\n![](https://pic.akorin.icu/20250228145758114.png)\n\n第一、二段的放大倍数相同。可见信号越小，放大倍数越大，反之信号越大，放大倍数越小，实现了信号的压缩。由于对称性，第三象限靠近原点的两端斜率为16，故在一共$8\\times2=16$根折线中，有4根同斜率。因此实际的折线数为$8\\times2-3=13$根，也就是13折线\n\nA律小信号的放大倍数（**斜率**）为 $\\frac{A}{1+\\ln A}$ ，13折线特性的放大倍数与之相近\n![](https://pic.akorin.icu/20250228151126918.png)\n\n### 4.4 量化信号的编码\n#### 4.4.1 自然二进制码和折叠二进制码\n\n![](https://pic.akorin.icu/20250228151955020.png)\n\n自然二进制码按照量化值的大小顺序排列，折叠二进制码分为两部分，分别表示符号以及绝对值，最高位是符号位，1为正数、0为负数；余下的3位表示绝对值\n\n#### 4.4.2 电话信号的编译码\n\n在压缩特性中，对输入和输出信号都进行了归一化处理，定义一个新的单位——**量化单位**，一个量化单位等于最小量化间隔\n\n对于正极性信号，13折线的第1段是 0~1/128 ，段内再细分为16份（固定16份），则最小量化间隔为1/2048\n\n则 1个量化单位=1/2048\n\n- 与均匀量化对应的编码：线性码，0~2048，11位码\n- 与非均匀量化对应的编码：非线性码 $c_1c_2c_3c_4c_5c_6c_7c_8$\n\n每个抽样值经量化后编程8位二进制码\n\n- $c_1$ ===> 符号码，当输入抽样值为正，$c_1=1$；抽样值为负， $c_1=0$\n- $c_2c_3c_4$ ===> 段码，段的编号1~8由原点开始计数，按照自然二进制码顺序从000~111，第三象限特性依然是从远点开始的顺序 ![](https://pic.akorin.icu/20250228152927062.png)\n- $c_5c_6c_7c_8$ ===> 段内码，编号1~16，按照自然二进制码从0000~1111，第三象限特性亦如此\n\n:::warning\n$c_1c_2c_3c_4$ 组合在一起是折叠二进制码， $c_5c_6c_7c_8$是自然二进制码\n:::\n\n### 4.5 PCM系统抗噪声性能\n\nPCM系统的噪声来源主要由两方面而来：\n- 误码噪声\n- 量化噪声\n\n二者相互独立\n\n#### 4.5.1 误码噪声功率\n\n将所有码位错码的误差功率求平均，称为**误码噪声功率**\n\n- 一个N位线性PCM码组自然二进制码的误码噪声功率为： \n$$\nN_e=\\frac{2^{2N}}{3}P_e(\\triangle v)^2\n$$\n\n- 一个N位线性PCM码组折叠二进制码的误码噪声功率为： \n$$\nN_e=\\frac{5}{4}(\\frac{2^{2N}}{3})P_e(\\triangle v)^2\n$$\n\n即折叠码的误码噪声平均功率是自然二进制码的1.25倍\n\n#### 4.5.2 PCM输出信噪比\n\n> 信号的平均功率： \n$$\nS_0=\\frac{M^2}{12}\\cdot(\\triangle v)^2=\\frac{2^{2N}}{12}\\cdot(\\triangle v)^2\n$$\n\n> 均匀量化的噪声功率：\n$$\nN_q=\\frac{(\\triangle v)^2}{12}\n$$\n\n> PCM系统的总输出信噪比：\n$$\n\\frac{S_0}{N}=\\frac{S_0}{N_q+N_e}\n$$\n> 对于自然二进制码：\n> - 当量化噪声为主要影响时：\n> $\\frac{S_0}{N}\\approx2^{2N}$\n> - 当误码噪声为主要影响时：\n> $\\frac{S_0}{N}\\approx\\frac{1}{4P_e}$\n\n> 对于折叠二进制码：\n> - 当量化噪声为主要影响时：\n> $\\frac{S_0}{N}\\approx2^{2N}$\n> - 当误码噪声为主要影响时：\n> $\\frac{S_0}{N}\\approx\\frac{1}{5P_e}$\n\n当$N=8$时，量化信噪比 $\\frac{S_0}{N_0}\\approx6.6\\times10^4$\n\n当 $P_e=10^{-6}\\sim{10}^{-5}$\n- 自然二进制码：$\\frac{S_0}{N_0}\\approx 2.5\\times 10^4 \\sim 2.5 \\times 10^5$\n- 折叠二进制码：$\\frac{S_0}{N_0}\\approx 2\\times 10^4 \\sim 2 \\times 10^5$\n\n当 $P_e < 10^{-6}$ 时，可以忽略误码噪声；\n\n当 $P_e > 10^{-5}$ 时，可以忽略量化噪声；\n\n\n### 4.6 差分脉冲编码调制DPCM\n\n不是直接对样值进行编码，而是对当前的样值与其预测值之间的差值进行编码，一般采用线性预测的方法来进行预测\n\n:::tip 线性预测\n线性预测时用前面若干个抽样值的**线性加权和**来预测当前的样值。\n设模拟基带信号表示为 $m(t)$，第k个抽样值表示为 $m_k$，其预测值表示为 $\\hat{m}=\\sum\\limits^p_{i-1}a_im_{k-i}$\n\n其中， $a_i$是预测系数，P是预测阶数，**预测值与前面P个抽样值有关**\n:::\n\n线性预测编码器原理框图：\n![](https://pic.akorin.icu/20250228213646183.png)\n\n实际中量化误差总是存在的，**因此预测值 $\\hat{m_k}$ 可以看成是带有量化误差的抽样信号 $m_k$**\n\n编码器是对预测误差 $e_k$ 进行编码，预测误差的动态范围通常较小，线性预测编码的实质利用了信号抽样值之间的相关性，减少了信号的冗余度，降低了比特率\n\n线性预测译码器结构框图：\n![](https://pic.akorin.icu/20250228213855964.png)\n\n预测误差的不同所带来的量化噪声分以下情况：\n- 预测误差 $e_k$ 范围限制在 $(-\\sigma,+\\sigma)$范围内。对预测误差进行量化，这种情况的噪声称为 **一般量化噪声**\n- 若响铃抽样值之间的变化超过$(-\\sigma,+\\sigma)$，或者或信号的斜率超过 $\\frac{\\sigma}{T}$，这种情况称为过载失真，这种情况的噪声称为 **过载量化噪声**\n\n> **自适应差分脉冲编码调制：ADPCM(Adaptive DPCM)**\n>\n> 语音信号是**非平稳信号**，其统计特性随时间而变化\n> 信号预测和量化器参数最好能根据输入信号来**自适应变化**\n> ADPCM一方面采用**自适应预测级数**；另一方面量化器的量化等级、量化电平也随信号**自适应调整**\n\n### 4.7 增量调制DM(Delta Modulation)\n\n**DM可以看成是特殊的DPCM**，在DPCM中当对预测误差进行**一位二进制编码**时，就是DM\n\n1bit编码输出对应的量化电平时$+\\sigma$或$-\\sigma$，分别表示预测误差的极性，是正或负\n\n当抽样频率足够高时，响铃抽样值的变化量很小，**用一位码有可能表示相邻抽样值的变化规律**\n\nDM编码器a\\c和译码器b\\d\n![](https://pic.akorin.icu/20250228221811434.png)\n\nDM是用增或减$\\sigma$电平的阶梯波，取近似原连续信号。通常用积分器代替延迟和相加电路，积分器输出在$T_s$期间信号的变化量\n\n量化误差的两种情况：\n- 一般量化\n- 过载量化\n![](https://pic.akorin.icu/20250228222050430.png)\n\n### 4.8 PCM信号的时分复用和复接\n\n> 复用：指多个用户共用同一物理信道，提高信息传输效率的技术\n> - 时分复用\n> - 频分复用\n> - 波分复用\n> - 码分复用\n\n:::tip 复接\n将低次群汇成高次群的过程\n:::\n:::tip 分接\n将高次群还原成低次群的过程\n:::\n\n对于TDM系统，同步信号是保证通信系统正常工作的必要条件：**码元同步（位同步）**、**帧同步（群同步）**\n\n#### 4.8.1 定量关系\n\n- 一帧的时长：抽样周期 $\\frac{1}{8000}=125 \\quad \\mu s$\n- 每帧分为**32个时隙**： $TS_0,TS_1, \\ldots ,TS_{31},$\n- 每个话路占一个**时隙** $\\frac{125}{32}\\approx 3.906 \\quad \\mu s$\n- 由于每路的抽样值还要编成为八位二进制码，所以**码元周期**为 $3.\\frac{906}{8}\\approx 0.488 \\mu s$\n- 基群的**码元速率**为 $8000 \\times 32 \\times 8 = 2048 Kbps$\n- PCM每16帧构成**复帧**， 复帧时长 $125 \\mu s \\times 16 = 2 \\quad ms$\n- PCM数字复接：4个低次群复接 ===> 1个高次群\n\n两类同步数字体系\n- 准同步复接PDH\n- 同步复接SDH\n\n### 4.9 帧同步\n#### 4.9.1 帧同步插入方式\n\n- 集中插入法\n- 分散插入法\n\n#### 4.9.2 帧同步码的识别\n\n**帧同步码识别器**由移位寄存器、相加器和判决器组成\n\n- 假同步：若信息序列中正好有连续位与帧同步码相同，则识别器也会输出正脉冲\n- 漏同步：当同步码中由错码时，可能不被识别\n\n## 5.基本的数字调制技术\n\n数字基带信号分为二进制和多进制两大类\n\n| 二进制    | 多进制 | 改进       |\n| --------- | ------ | ---------- |\n| 2ASK      | MASK   | QAM        |\n| 2FSK      | MFSK   | MSK,GMSK   |\n| 2PSK,2DSK | MPSK   | QPSK,DQPSK |\n\n### 5.1 二进制数字信号的调制\n#### 5.1.1 二进制振幅键控(2ASK)\n\nASK(Amplitude Shift Keying)，又称幅移键控\n- 传号“1” ====> 载波有振幅\n- 空号“0” ====> 载波振幅为0\n\n数字基带信号 $s(t)=\\sum\\limits^\\infty_{n=-\\infty}a_ng(t-nT_B)$\n\n载波 $c(t)=A\\cos2\\pi f_ct$\n\n> 则2ASK信号为：\n> $s_m(t)=s(t)c(t)$ 或\n$$\ns_m(t)=\n\n\\begin{cases} s_1(t)=A\\cos 2\\pi f_c t, & s(t)=1 \\\\ s_0(t)=0, & s(t)=0 \\end{cases}\n\\quad\n0\\le t\\le T_B\n$$\n\n![](https://pic.akorin.icu/20250301141401949.png)\n\n> 2ASK信号的功率谱密度：\n> $P_{2ASK}(f)=\\frac{A^2}{4}[P_s(f+f_c)+P_s(f-f_c)]$\n> ![](https://pic.akorin.icu/20250301141712773.png)\n\n> 2ASK信号的带宽：$2R_B$\n\n2ASK信号的功率谱密度是将单极性基带序列的功率谱密度平移至中心频率$f=f_e$处，属于线性调制。其中$R_B$是基带信号的码元传输速率，**2ASK信号的的带宽即为$2R_B$**。功率谱中含有离散谱和连续谱，离散谱可以作为导频信号，有助于接收端方便地提取载波信号，实现相干解调\n\n> 2ASK信号的调制\n> - 模拟相乘法：![](https://pic.akorin.icu/20250301145927516.png)\n> - 数字键控法：![](https://pic.akorin.icu/20250301145957444.png)\n\n#### 5.1.2 二进制频移键控(2FSK)\n\nFSK(Frequency Shift Keying)又称频移键控\n- 传号“1” ====> 载波频率 $f_1$\n- 空号“0” ====> 载波频率 $f_2$\n\n实现过程中又分为**相位不连续**及**相位连续**两种频移键控信号\n\n> **相位不连续的2FSK信号**\n>\n> 数字基带信号 $s(t)$ 控制开关K以键控方式分别接通两个载波，产生频移键控信号\n> ![](https://pic.akorin.icu/20250301151035577.png)\n> 相位不连续的2FSK信号二点时域表达式为：\n$$\ns_m(t)=\n\\begin{cases} s_1(t)=A\\cos 2\\pi f_1t, & s(t)=1 \\\\ s_0(t)=A\\cos 2\\pi f_2 t, & s(t)=0 \\end{cases}\n\\quad\n0\\le t\\le T_B\n$$\n\n> **相位连续的2FSK信号**\n>\n> 数字基带信号 $s(t)$ 控制压控振荡器VCO的振荡频率，产生频移键控信号。压控振荡器的中心振荡频率 $f_c=\\frac{1}{2}(f_1+f_2)$\n> ![](https://pic.akorin.icu/20250301151432843.png)\n> 连续香味2FSK信号的时域表达式为：\n$$\ns_m(t)=A\\cos[2\\pi f_ct+k_f]\\int^t_{-\\infty}s(\\tau)d\\tau\n$$\n其中 $k_f$ 是调频器的调频灵敏度\n![](https://pic.akorin.icu/20250301151909222.png)\n\n一路2FSK信号可以等效成两路2ASK信号的叠加，且这两路2ASK信号中各自携带的数字基带信号互为反码，因而2FSK信号的功率谱密度等效于两路2ASK信号功率谱密度之和\n![](https://pic.akorin.icu/20250301151917860.png)\n\n由上图可知，2FSK信号的功率谱密度与数字基带信号的功率谱密度形状完全不同，属于非线性调制。\n\n> 2FSK信号的带宽： $|f_2-f_1|+2R_B$\n\n:::warning \n当$|f_2-f_1|\\ge 2R_b$时，2FSK信号可以分离成两路独立的2ASK信号；当$|f_2-f_1|\\le   2R_b$时，不能直接滤波分离，这种特性将会影响2FSK信号解调方法的选择\n:::\n\n> **2FSK两个信号波形之间的互相关系数**\n>\n> 从2FSK信号的频谱结构可看出，它的带宽参数与 $|f_2-f_1|$ 有关。相位不连续和相位连续的2FSK信号本质就是 $|f_2-f_1|$ 与基带信号码元速率间数值比率不同引起的\n> 定义2FSK两个信号波形 $s_1(t),s_0(t)$之间互相关系数为：\n$$\n\\rho=\\frac{1}{E_b}\\int^{T_B}_0s_1(t)s_0(t)dt\n$$\n式中\n$$\nE_b=\\int^{T_B}_0s_1^2(t)dt=\\int^{T_B}_0s_0^2(t)dt=\\frac{1}{2}A^2T_B\n$$\n将 $s_1(t),s_2(t)$ 带入上式，并限定$2\\pi f_c T_B$是$\\pi$的整数倍整理得：\n\n$$\n\\rho = Sa [2\\pi (2 \\triangle f)T_B]\n$$\n\n说明互相关系数$\\rho$是$2\\triangle f$与$T_B$的函数，函数范围$[-1,+1]$，选取不同的载波频率和基带信号码元速率值，会产生不同的$\\rho$值，这将影响2FSK信号带宽参数的变化\n\n在实际应用中应尽可能减小信号带宽且利于解调，多选择 $\\rho=0$ 。这时 $s_1(t),s_2(t)$ 正交，有 $2\\pi(2 \\triangle f)T_B = n\\pi$ ，所以两个载频的频率间隔为：\n$$\n2\\triangle f=\\frac{n}{2T_B}\n$$\n取 $n=1$ ，信号带宽最小，时2FSK信号的形式之一，称为**最小移频键控MSK信号**\n\n\n#### 5.1.3 二进制相移键控(2PSK与2DPSK)\n\nPSK(Phase Shift Keying)又称移相键控\n\nDPSK(Differential Phase Shift Keying)又称差分相移键控或相对相移键控\n\n- 二进制：2PSK,2DPSK\n- 四进制：QPSK,QDPSK\n- M进制：MPSK,MDPSK\n\n> 移相键控信号的时域表达式：\n$$\n\\varphi=\n\\begin{cases} 0, & s(t)=1 \\\\ \\pi, & s(t)=0 \\end{cases}\n$$\n\n![](https://pic.akorin.icu/20250301162051334.png)\n\n> 2PSK信号的时域表达式：\n$$\ns_m(t)=s(t)c(t)=\n\\begin{cases} s_1(t)=A\\cos 2\\pi f_c t, & s(t)=1 \\\\ s_0(t)=-A\\cos 2\\pi f_c t, & s(t)=0 \\end{cases}\n\\quad\n0\\le t\\le T_B\n$$\n\n> 2DPSK信号可以用相邻码元的载频初相差 $\\triangle \\varphi$ 来表示传号和空号\n\n$$\n\\triangle \\varphi=\\varphi_n-\\varphi_{n-1}=\n\\begin{cases} \\pi, & s(t)=1 \\\\ 0, & s(t)=0 \\end{cases}\n$$\n\n> 实现方法：\n>\n> - 将二进制基带序列进行差分编码： $b_n=a_n\\oplus b_{n-1}$ ， ${a_n}$ 是绝对码，${b_n}$ 是相对码，\n> - 对 ${b_n}$ 进行2PSK\n\n> 键控法产生2PSK和2DPSK\n> ![](https://pic.akorin.icu/20250301163545985.png)\n\n2PSK和2DPSK信号的相位及波形关系：\n![](https://pic.akorin.icu/20250301163733470.png)\n\n> **PSK的功率谱密度**\n>\n> 2PSK信号实质上是双极性的2ASK信号，与2ASK不同的是，当“1”和“0”等概时，2PSK信号不含 $f_c$ 冲激成分。 2PSK属于线性调制，2DPSK和2PSK的功率谱密度相同\n\n![](https://pic.akorin.icu/20250301165916369.png)\n\n### 5.2 二进制数字解调技术与抗噪声性能\n\n二进制数字解调方法分为非相干解调、相干解调和匹配滤波器三大类，采用不同解调方案的系统其抗噪性能有所不同。总体来说**匹配滤波器**的抗噪声性能最好，相干解调次之，非相干解调较差但设备简单。接受模型的性能参数为误码率或误比特率：\n![](https://pic.akorin.icu/20250301171306685.png)\n\n> **常用转换**\n> 设接收机带通滤波器带宽 $B=2R_B$\n> - $\\sigma_n^2=n_0B=n_0 \\cdot 2R_B = \\frac{2n_0}{T_B}$\n> - 比特能量： $E_b=\\frac{1}{2}A^2T_B$\n> - 解调器输入端信噪比： $r=\\frac{A^2}{2\\sigma^2}$ ，大信噪比条件： $r\\gg 1$\n\n\n#### 5.2.1 2ASK信号的解调\n\n2ASK信号的解调有非相干解调、相干解调和匹配滤波器三种\n\n![](https://pic.akorin.icu/20250301172141564.png)\n\n> **非相干解调**\n\n利用包络检波器可实现2ASK的**非相干解调**，不需要载波提取电路\n![](https://pic.akorin.icu/20250301171347772.png)\n\n- 发送：\n$$\ns_m(t)=\\begin{cases} s_1(t)=A\\cos \\omega_c t, & 1 \\\\ s_0(t)=0, & 0 \\end{cases}\n\\quad\n0\\le t\\le T_B\n$$\n\n- 接收：\n$$\nr(t)=s_m(t)+n_i(t)=\\begin{cases} A\\cos \\omega_c t +n_i (t), & 1 \\\\ n_i(t), & 0 \\end{cases}\n$$\n\n- 在大信噪比条件下，最佳门限近似为：\n$$\nV^*_d\\approx \\frac{A}{2}\n$$\n- 在大信噪比条件下，误码率近似为：\n$$\nP_e\\approx \\frac{1}{2} \\exp(-\\frac{r}{4})\n$$\n\n> **相干解调**\n\n需要载波提取电路\n![](https://pic.akorin.icu/20250301172606055.png)\n\n- 最佳门限：\n$$\nV_d^*=\\frac{A}{2}\n$$\n- 误码率：\n$$\nP_e=\\frac{1}{2} erfc(\\sqrt{\\frac{A^2}{8\\sigma^2_n}})\n$$\n当 $r=\\frac{A^2}{2\\sigma^2} \\gg 1$ （更大概率考）\n$$\nP_e \\approx \\frac{1}{\\sqrt{\\pi r}}\\exp(-\\frac{r}{4})\n$$ \n\n:::tip 互补误差函数erfc\n$erfc(x)=\\frac{2}{\\sqrt{\\pi}}\\int^\\infty_x e^{-y^2}dy$\n\n$erf$ 是高斯误差函数，与 $erfc$ 的关系是：\n\n$erf(x)+erfc(x)=1$\n\n一般是查表获得\n:::\n\n> **匹配滤波器**\n\n匹配滤波器是一种保证抽样判决时刻输出信噪比最大的线性滤波器，同时也是一种最佳接收机\n\n:::tip 最佳接收机\n指误码率最小的接收机，而误码率最小和信噪比最大是等价的，在抽样判决前加一个匹配滤波器可以获得最佳的抗噪声性能\n:::\n\n- 匹配滤波器的结构\n![](https://pic.akorin.icu/20250301210147124.png)\n\n- 匹配滤波器解调\n![](https://pic.akorin.icu/20250301210209491.png)\n\n由随机信号可知，Z是高斯随机变量，其均值和方差分别为：\n$E(Z)=0$\n\n$$\nD(Z)=\\frac{n_0}{2}E_b\n$$\n\n- 平均误码率：\n$$\nP_e=\\frac{1}{2}erfc(\\sqrt{\\frac{A^2T_B}{4n_0}})\n$$\n\n而2ASK的平均误码率：\n$$\nP_e=\\frac{1}{2}erfc(\\sqrt{\\frac{A^2T_B}{8n_0}})\n$$\n由上述两式对比可知，匹配滤波器解调的系统平均误码率小，接受性能最佳\n\n#### 5.2.2 2FSK信号的解调\n\n2FSK解调有非相干解调、相干解调和匹配滤波器\n\n> **非相干解调**\n\n常用的2FSK信号非相干解调有**包络检波法、过零检测法**等\n\n- 包络检波法：此方案的条件是2FSK信号中两载频之差 $|f_2-f_1|\\ge 2R_B$ ，这样就可以将一路2FSK信号分离成两路2ASK信号\n![](https://pic.akorin.icu/20250301210852070.png)\n\n- 判决规则：\n\n| $y_1,y_0$的关系 | 判决 |\n| ----------- | ---- |\n| $y_1\\ge y_0$    | 判1  |\n| $y_1< y_0$       | 判0  |\n\n- 系统的平均误码率：\n$$\nP_e=P_{e1}=\\frac{1}{2}\\exp{(-\\frac{r}{2})}\n$$\n\n----\n\n- 过零检测法：基本思想是基于2FSK信号的两载频郭零点次数的不同，通过检测过零点数恢复基带信号\n![](https://pic.akorin.icu/20250301211427894.png)\n\n- 系统平均误码率：与包络检波法相同\n$$\nP_e=P_{e1}=\\frac{1}{2}\\exp{(-\\frac{r}{2})}\n$$\n\n> **相干解调**\n此方案的应用条件是： 两载频之差 $|f_2-f_1|\\ge 2R_B$\n![](https://pic.akorin.icu/20250301211703038.png)\n\n- 抽样判决规则：\n\n| $l=y_1-y_0$ | 判决 |\n| -------- | --- |\n| $l\\ge 0$ | 判1 |\n| $l<0$    | 判0 |\n\n- 平均误码率：\n$$\nP_e=P_{e1}=\\frac{1}{2}erfc(\\frac{A}{2\\sigma_n})=\\frac{1}{2}erfc(\\sqrt{\\frac{r}{2}})\n$$\n当 $r\\gg_1$ 时，可近似为：\n$$\nP_e \\approx \\frac{1}{\\sqrt{2\\pi r}}\\exp(-\\frac{r}{2})\n$$\n\n> **匹配滤波器**\n\n![](https://pic.akorin.icu/20250301212846942.png)\n\n- 抽样判决规则：\n\n| $l=y_1-y_0$ | 判决 |\n| ----------- | ---- |\n| $l\\ge 0$    | 判1  |\n| $l<0$       | 判0  |\n\n$$\nP_e=\\frac{1}{2}erfc(\\sqrt{\\frac{E_b}{2n_0}})=\\frac{1}{2}erfc(\\sqrt{\\frac{A^2T_B}{4n_0}})\n$$\n\n#### 5.2.3 2PSK和2DPSK信号的解调\n\n由于2PSK和2DPSK信号来说，信息是寄予相位之中，不能用包络检波器完成解调，但2DPSK信号是用前后码元相对载波相位表示信息，利用这个特点可以完成非相干解调。故2PSK只有相干解调和匹配滤波器，2DPSK有非相干解调、相干解调和匹配滤波器\n\n> **非相干解调**\n>\n> 只有2DPSK可以用这种方法，2PSK不能\n\n![](https://pic.akorin.icu/20250301213437267.png)\n\n- 经过低通滤波器输出抽样信号为：\n$$\ny(nT_B)=\\frac{A^2}{2}\\cos(\\varphi_n-\\varphi_{n-1})\n$$\n根据2DPSK信号的定义：\n$$\n\\triangle \\varphi=\\varphi_n-\\varphi_{n-1}=\n\\begin{cases} \\pi, & 1 \\\\ 0, &  0\\end{cases}\n$$\n\n- 设定最佳判决门限为0，则判决规则为：\n| $y(nT_B)$   | 判决 |\n| ----------- | ---- |\n| $y(nT_B)<0$ | 判1  |\n| $y(nT_B)>0$ | 判0  |\n\n- 误码率：\n$$\nP_e=\\frac{1}{2}\\exp({-\\frac{A^2}{2\\sigma^2_n}})=\\frac{1}{2}\\exp(-r)\n$$\n其中 $\\sigma_n^2=2n_0 R_B$\n\n> **相干解调**\n>\n> 2PSK的相干解调\n\n![](https://pic.akorin.icu/20250301220921052.png)\n\n2PSK信号等效于双极性2ASK\n\n\n- 设定最佳判决门限为0，则判决规则为：\n| $y(nT_B)$   | 判决 |\n| ----------- | ---- |\n| $y(nT_B)>0$ | 判1  |\n| $y(nT_B)<0$ | 判0  |\n\n- 误码率：\n$$\nP_e=\\frac{1}{2} erfc(\\sqrt{\\frac{A^2}{2\\sigma^2_n}})=\\frac{1}{2}erfc(\\sqrt r)\n$$\n当 $r\\gg1$ 时，可近似为：\n$$\nP_e \\approx \\frac{1}{2\\sqrt{\\pi r}}\\exp(-r)\n$$\n\n> 2DPSK的相干解调\n\n![](https://pic.akorin.icu/20250301221248967.png)\n\n判决输出的是相对码序列，经过差分译码得到绝对码。当相对码出现误码时，差分译码就会出现错上加错的情况，使系统的误码率增加。通过PSK的误码率计算DPSK的误码率\n\n- DPSK相干解调系统的误码率：\n$$\nP'_e=2P_e(1-P_e)\n$$\n当 $P_e$ 较小时，可近似为：\n$$\nP'_e=2P_e\n$$\n\n\n> **匹配滤波器**\n\n利用匹配滤波器实现2PSK信号解调：\n![](https://pic.akorin.icu/20250301221801315.png)\n\n- 发送 $s_1(t)$ 时，$y(nT_B)=E_b+Z$\n- 发送 $s_0(t)$ 时，$y(nT_B)=-E_b+Z$\n\n- 设定最佳判决门限为0，则判决规则为：\n| $y(nT_B)$   | 判决 |\n| ----------- | ---- |\n| $y(nT_B)>0$ | 判1  |\n| $y(nT_B)<0$ | 判0  |\n\n- 系统统计平均误码率：\n$$\nP_e=\\frac{1}{2}erfc(\\sqrt{\\frac{E_b}{n_0}})\n$$\n\n----\n\n**三中解调方式的抗噪声性能**\n|       | 非相干解调                        | 相干解调                                    | 匹配滤波器解调                              |\n| ----- | --------------------------------- | ------------------------------------------- | ------------------------------------------- |\n| 2ASK  | $\\frac{1}{2}\\exp{(-\\frac{r}{4})}$ | $\\frac{1}{\\sqrt{\\pi r}}\\exp(-\\frac{r}{4})$  | $\\frac{1}{2} erfc(\\sqrt{\\frac{E_b}{4n_0}})$ |\n| 2FSK  | $\\frac{1}{2}\\exp{(-\\frac{r}{2})}$ | $\\frac{1}{\\sqrt{2\\pi r}}\\exp(-\\frac{r}{2})$ | $\\frac{1}{2} erfc(\\sqrt{\\frac{E_b}{2n_0}})$ |\n| 2PSK  |                                   | $\\frac{1}{2\\sqrt{\\pi r}}\\exp(-r)$           | $\\frac{1}{2} erfc(\\sqrt{\\frac{E_b}{n_0}})$  |\n| 2DPSK | $\\frac{1}{2}\\exp(-r)$             | $\\frac{1}{\\sqrt{\\pi r}}\\exp(-r)$            |                                             |\n\n\n### 5.3 四进制相移键控(QPSK)\n### 5.4 四进制差分相移键控(QDPSK)\n\n...\n\n## 6.现代数字调制技术\n### 6.1  正交振幅调制(QAM)\n\nQAM用两路独立的数字基带信号对两个相互正交的同频载波进行抑制载波的DSB调制，利用这种已调信号在同一带宽内频谱正交的性质来实现两路并行的数字传输\n\n ![](https://pic.akorin.icu/20250302194502983.png)\n 输入的二进制序列经过串/并变换为输出速率减半的两路并行序列，再分别经过2电平到L电平的变换，形成L电平（L进制）的基带信号\n\n 信号矢量断电的分布图称为星座图，通常可以用星座图描述QAM信号的信号空间分布状态\n![](https://pic.akorin.icu/20250302195647371.png)\n\n### 6.2 正交频分复用(OFDM)\n\n正交频分复用是一种并行机制，有较强的抗多径传播和频率选择性衰落的能力以及较高的频谱利用率。\n\nOFDM是一种高效调制技术，其基本原理是将发送的数据流分散到许多个子载波上，使各子载波的信号速率大为降低，从而提高抗多径和抗衰落的能力。OFDM方式种各子载波频谱有1/2重叠，但保持相互正交\n\n![](https://pic.akorin.icu/20250302200636174.png)\n与一般的频分复用(FDM)技术不同，OFDM系统种各子信道在时间上相互正交，在频率上互相重叠，使得ODFM系统比FDM系统节省了很多带宽\n\nOFDM技术的主要思想是将指配的信道分成许多正交子信道，在每个子信道上进行窄带调制和传输，信号带宽小于信道的相关带宽\n\n- OFDM的调制\n![](https://pic.akorin.icu/20250302200923965.png)\n\n- OFDM的解调\n![](https://pic.akorin.icu/20250302200949879.png)\n\n## 7.纠错编码技术\n### 7.1 纠错编码的概念\n\n数字信号传输过程中，由于信道传输特性不理想及加性噪声的影响，不可避免地会发生错误。可用如下三种方法减小误码率：\n- 提高信道容量\n- 降低编码效率\n- 增加码长\n\n#### 7.1.1 错码的分类\n\n按照错码分布规律的不同，可分为三类：\n\n- 随机性错码：错码的出现是随机的，它由高斯白噪声引起\n- 突发性错码：错码是成串集中出现的，产生突发错码的主要原因是脉冲干扰和信道中的衰落\n- 混合型错码：既有随即错吗又有突发错码\n\n#### 7.1.2 差错控制方法\n\n- 前向纠错：接收端能检测出错码，并可以确定错码的位置，并予纠正\n- 检错重发：接收端检测出错码通知发端重发\n- 反馈校验：接收端将收到的信号原封不动发回发端，由发端将其与原发信号相比较，若有错误则重发\n\n#### 7.1.3 差错控制编码基本原理\n\n- 利用冗余度：在信息码原序列后增加一些监督码元。监督码元越多，检、纠错能力越强\n- 噪声均化（随机化）：设法把集中出现的突发性差错分摊开来，变成随机性差错\n\n#### 7.1.4 码距与纠检错性能\n\n- 分组码：将信息码分组，为每组信息码附加若干监督码元形成的码集合\n- 特点：分组码中的监督码元仅监督本码组中的信息码元\n- 符号：(n,k)\n> - k: 码组中**信息码元**的数目\n> - n: 码组的总位数，又称为**码组长度**\n> - r: $r=n-k$ 码组中**监督码元**的数目\n> 编码效率： $\\frac{k}{n}$\n> 冗余度： $\\frac{n-k}{k}$\n\n![](https://pic.akorin.icu/20250302202607676.png)\n\n- 码组重量： 码组中'1'的数目\n- 码距d：两个码组对应位上**不同的码元个数**，称为**汉明距离**\n- 最小码距 $d_0$ ： 码集合中任意两两码组间距离的最小值\n\n> **码距与码集合检、纠错能力的关系**\n> - 检测 e 个错码，要求最小码距 $d_0\\ge e+1$\n> - 纠正 t 个错码，要求最小码距 $d_0\\ge 2t+1$\n> - 纠正 t 个错码、同时检测 e 个错码，要求最小码距 $d_0\\ge e+t+1 \\quad (e>t)$\n\n### 7.2 线性分组码\n\nr位监督码对应r个校对子，就有 $2^r$ 种组合，用其中一种组合表示无措，其余 $2^r-1$ 种组合表示错码的位置\n\n若只错一位，分组码 (n,k) 种的错码有n个可能的位置，要用r位表示这n个错码的位置，r取最小值 $2^r-1 \\ge n$\n\n:::tip 汉明码\n能纠正一位错码，且 $2^r-1=n$ 的线性分组码，称为汉明码\n\n其编码效率为：\n$$\n\\frac{k}{n}=\\frac{2^r-1-r}{2^r-1}=1-\\frac{r}{2^r-1}=1-\\frac{r}{n}\n$$\n当n很大时，编码效率接近1.可见汉明码是一种高效码\n:::\n\n> e.g.\n> 已知(7,4)码，r=3 则 $2^3-1=7=n$ 共有3个监督方程构成3个校对子\n>\n> 建立监督方程：\n> $a_6\\oplus a_5\\oplus a_3\\oplus a_2\\oplus = 0$\n> $a_5\\oplus a_4\\oplus a_3\\oplus a_1\\oplus = 0$\n> $a_6\\oplus a_5\\oplus a_4\\oplus a_0\\oplus = 0$\n>\n> 建立编码方程：\n> $a_2=a_6\\oplus a_5\\oplus a_3\\oplus$\n> $a_1=a_5\\oplus a_4\\oplus a_3\\oplus$\n> $a_0=a_6\\oplus a_5\\oplus a_4\\oplus$\n\n| $S_1S_2S_3$ |          |\n| ----------- | -------- |\n| 000         | 无错     |\n| 001         | $a_0$ 错 |\n| 010         | $a_0$ 错 |\n| 100         | $a_0$ 错 |\n| 110         | $a_0$ 错 |\n| 011         | $a_0$ 错 |\n| 111         | $a_0$ 错 |\n| 101         | $a_0$ 错 |\n\n> 根据监督方程写出矩阵形式：\n\n$$\n\\begin{bmatrix}\n  1101100 \\\\\n  0111010 \\\\\n  1110001\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n  a_6 \\\\\n  a_5 \\\\\n  a_4 \\\\\n  a_3 \\\\\n  a_2 \\\\\n  a_1 \\\\\n  a_0 \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  0 \\\\\n  0 \\\\\n  0 \\\\\n\\end{bmatrix}\n$$\n记为： $H\\cdot A^T=0$ ，当 $H=[P \\quad I_r]$ 称H为典型监督矩阵（含单位阵）\n\n> 根据编码方程写出生成矩阵：\n$$\n\\begin{bmatrix}\n  a_2\\\\\n  a_1 \\\\\n  a_0\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  1 & 1 & 1 & 0  \\\\\n  1 & 1 & 0 & 1  \\\\\n  1 & 0 & 1 & 1  \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n  a_6 \\\\\n  a_5 \\\\\n  a_4 \\\\\n  a_3\n\\end{bmatrix}\n$$\n转置后可得：\n$$\n\\begin{bmatrix}\n  a_2 & a_1 & a_0\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  a_6 & a_5 & a_4 & a_3\n\\end{bmatrix}\n\\begin{bmatrix}\n  1 & 1 & 1  \\\\\n  1 & 1 & 0  \\\\\n  1 & 0 & 1  \\\\\n  0 & 1 & 1  \\\\\n\\end{bmatrix}\n=\\begin{bmatrix}\n  a_6 & a_5 & a_4 & a_3\n\\end{bmatrix}Q\n$$\n其中 $Q=P^T$\n\n最后科的生成矩阵G：\n$$\nG=[I_k \\quad Q] = \n\\begin{bmatrix}\n  1 & 0 & 0 & 0 & \\vdots & 1 & 1 & 1  \\\\\n  0 & 1 & 0 & 0 & \\vdots & 1 & 1 & 0  \\\\\n  0 & 0 & 1 & 0 & \\vdots & 1 & 0 & 1  \\\\\n  0 & 0 & 0 & 1 & \\vdots & 0 & 1 & 1  \\\\\n\\end{bmatrix}\n$$\n由生成矩阵G可以产生整个码组，前一半（单位矩阵）是信息码元，后一半是监督码元的编码矩阵\n\n通信中发送的码组就是上式的A。设接受矩阵是B，则错码行矩阵为E\n$E=B-A$\n\n- 译码计算：\n$$\nBH^T\n$$\n\n> e.g.\n>\n> 设发码组： $A=1100010$\n> 设收码组： $A=1000010$\n>\n$$\nBH^T=\\begin{bmatrix}\n  1000010\n\\end{bmatrix}\n\\begin{bmatrix}\n  101  \\\\\n  111  \\\\\n  011  \\\\\n  110  \\\\\n  100  \\\\\n  010  \\\\\n  001  \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  111\n\\end{bmatrix}\n$$\n$\\therefore$ $a_5$ 错误\n\n> **线性分组码的性质**\n>\n> - 封闭性：线性码中两个码组之和仍未这种码中的一个码组\n> - 两个码组间的距离必是零一码组的重量\n> - 除全0码组之外，编码的最小码重是码集合的最小码距\n> -线性分组码中必有全0码（信息码全0，监督码全0）\n\n### 7.3 循环码\n\n\n\n### 7.4 实用循环码\n\n\n\n### 7.5 卷积码\n\n\n","cover":"https://pic.akorin.icu/uj64pr7a.png","date":"2025-01-27"}]
